// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "telegramcore.h"
#include "telegramapi.h"
#include <QDebug>

qint32 TelegramCore::mTimeOut = 30000;

TelegramCore::TelegramCore(QObject *parent) :
    QObject(parent)
{
}

void TelegramCore::setApi(TelegramApi *api)
{
    mApi = api;

    connect(api, &TelegramApi::accountRegisterDeviceAnswer, this, &TelegramCore::onAccountRegisterDeviceAnswer);
    connect(api, &TelegramApi::accountRegisterDeviceError, this, &TelegramCore::onAccountRegisterDeviceError);
    
    connect(api, &TelegramApi::accountUnregisterDeviceAnswer, this, &TelegramCore::onAccountUnregisterDeviceAnswer);
    connect(api, &TelegramApi::accountUnregisterDeviceError, this, &TelegramCore::onAccountUnregisterDeviceError);
    
    connect(api, &TelegramApi::accountUpdateNotifySettingsAnswer, this, &TelegramCore::onAccountUpdateNotifySettingsAnswer);
    connect(api, &TelegramApi::accountUpdateNotifySettingsError, this, &TelegramCore::onAccountUpdateNotifySettingsError);
    
    connect(api, &TelegramApi::accountGetNotifySettingsAnswer, this, &TelegramCore::onAccountGetNotifySettingsAnswer);
    connect(api, &TelegramApi::accountGetNotifySettingsError, this, &TelegramCore::onAccountGetNotifySettingsError);
    
    connect(api, &TelegramApi::accountResetNotifySettingsAnswer, this, &TelegramCore::onAccountResetNotifySettingsAnswer);
    connect(api, &TelegramApi::accountResetNotifySettingsError, this, &TelegramCore::onAccountResetNotifySettingsError);
    
    connect(api, &TelegramApi::accountUpdateProfileAnswer, this, &TelegramCore::onAccountUpdateProfileAnswer);
    connect(api, &TelegramApi::accountUpdateProfileError, this, &TelegramCore::onAccountUpdateProfileError);
    
    connect(api, &TelegramApi::accountUpdateStatusAnswer, this, &TelegramCore::onAccountUpdateStatusAnswer);
    connect(api, &TelegramApi::accountUpdateStatusError, this, &TelegramCore::onAccountUpdateStatusError);
    
    connect(api, &TelegramApi::accountGetWallPapersAnswer, this, &TelegramCore::onAccountGetWallPapersAnswer);
    connect(api, &TelegramApi::accountGetWallPapersError, this, &TelegramCore::onAccountGetWallPapersError);
    
    connect(api, &TelegramApi::accountCheckUsernameAnswer, this, &TelegramCore::onAccountCheckUsernameAnswer);
    connect(api, &TelegramApi::accountCheckUsernameError, this, &TelegramCore::onAccountCheckUsernameError);
    
    connect(api, &TelegramApi::accountUpdateUsernameAnswer, this, &TelegramCore::onAccountUpdateUsernameAnswer);
    connect(api, &TelegramApi::accountUpdateUsernameError, this, &TelegramCore::onAccountUpdateUsernameError);
    
    connect(api, &TelegramApi::accountGetPrivacyAnswer, this, &TelegramCore::onAccountGetPrivacyAnswer);
    connect(api, &TelegramApi::accountGetPrivacyError, this, &TelegramCore::onAccountGetPrivacyError);
    
    connect(api, &TelegramApi::accountSetPrivacyAnswer, this, &TelegramCore::onAccountSetPrivacyAnswer);
    connect(api, &TelegramApi::accountSetPrivacyError, this, &TelegramCore::onAccountSetPrivacyError);
    
    connect(api, &TelegramApi::accountDeleteAccountAnswer, this, &TelegramCore::onAccountDeleteAccountAnswer);
    connect(api, &TelegramApi::accountDeleteAccountError, this, &TelegramCore::onAccountDeleteAccountError);
    
    connect(api, &TelegramApi::accountGetAccountTTLAnswer, this, &TelegramCore::onAccountGetAccountTTLAnswer);
    connect(api, &TelegramApi::accountGetAccountTTLError, this, &TelegramCore::onAccountGetAccountTTLError);
    
    connect(api, &TelegramApi::accountSetAccountTTLAnswer, this, &TelegramCore::onAccountSetAccountTTLAnswer);
    connect(api, &TelegramApi::accountSetAccountTTLError, this, &TelegramCore::onAccountSetAccountTTLError);
    
    connect(api, &TelegramApi::accountSendChangePhoneCodeAnswer, this, &TelegramCore::onAccountSendChangePhoneCodeAnswer);
    connect(api, &TelegramApi::accountSendChangePhoneCodeError, this, &TelegramCore::onAccountSendChangePhoneCodeError);
    
    connect(api, &TelegramApi::accountChangePhoneAnswer, this, &TelegramCore::onAccountChangePhoneAnswer);
    connect(api, &TelegramApi::accountChangePhoneError, this, &TelegramCore::onAccountChangePhoneError);
    
    connect(api, &TelegramApi::accountUpdateDeviceLockedAnswer, this, &TelegramCore::onAccountUpdateDeviceLockedAnswer);
    connect(api, &TelegramApi::accountUpdateDeviceLockedError, this, &TelegramCore::onAccountUpdateDeviceLockedError);
    
    connect(api, &TelegramApi::accountGetAuthorizationsAnswer, this, &TelegramCore::onAccountGetAuthorizationsAnswer);
    connect(api, &TelegramApi::accountGetAuthorizationsError, this, &TelegramCore::onAccountGetAuthorizationsError);
    
    connect(api, &TelegramApi::accountResetAuthorizationAnswer, this, &TelegramCore::onAccountResetAuthorizationAnswer);
    connect(api, &TelegramApi::accountResetAuthorizationError, this, &TelegramCore::onAccountResetAuthorizationError);
    
    connect(api, &TelegramApi::accountGetPasswordAnswer, this, &TelegramCore::onAccountGetPasswordAnswer);
    connect(api, &TelegramApi::accountGetPasswordError, this, &TelegramCore::onAccountGetPasswordError);
    
    connect(api, &TelegramApi::accountGetPasswordSettingsAnswer, this, &TelegramCore::onAccountGetPasswordSettingsAnswer);
    connect(api, &TelegramApi::accountGetPasswordSettingsError, this, &TelegramCore::onAccountGetPasswordSettingsError);
    
    connect(api, &TelegramApi::accountUpdatePasswordSettingsAnswer, this, &TelegramCore::onAccountUpdatePasswordSettingsAnswer);
    connect(api, &TelegramApi::accountUpdatePasswordSettingsError, this, &TelegramCore::onAccountUpdatePasswordSettingsError);
    
    
    connect(api, &TelegramApi::authImportBotAuthorizationAnswer, this, &TelegramCore::onAuthImportBotAuthorizationAnswer);
    connect(api, &TelegramApi::authImportBotAuthorizationError, this, &TelegramCore::onAuthImportBotAuthorizationError);
    
    connect(api, &TelegramApi::authCheckPhoneAnswer, this, &TelegramCore::onAuthCheckPhoneAnswer);
    connect(api, &TelegramApi::authCheckPhoneError, this, &TelegramCore::onAuthCheckPhoneError);
    
    connect(api, &TelegramApi::authSendCodeAnswer, this, &TelegramCore::onAuthSendCodeAnswer);
    connect(api, &TelegramApi::authSendCodeError, this, &TelegramCore::onAuthSendCodeError);
    
    connect(api, &TelegramApi::authSendCallAnswer, this, &TelegramCore::onAuthSendCallAnswer);
    connect(api, &TelegramApi::authSendCallError, this, &TelegramCore::onAuthSendCallError);
    
    connect(api, &TelegramApi::authSignUpAnswer, this, &TelegramCore::onAuthSignUpAnswer);
    connect(api, &TelegramApi::authSignUpError, this, &TelegramCore::onAuthSignUpError);
    
    connect(api, &TelegramApi::authSignInAnswer, this, &TelegramCore::onAuthSignInAnswer);
    connect(api, &TelegramApi::authSignInError, this, &TelegramCore::onAuthSignInError);
    
    connect(api, &TelegramApi::authLogOutAnswer, this, &TelegramCore::onAuthLogOutAnswer);
    connect(api, &TelegramApi::authLogOutError, this, &TelegramCore::onAuthLogOutError);
    
    connect(api, &TelegramApi::authResetAuthorizationsAnswer, this, &TelegramCore::onAuthResetAuthorizationsAnswer);
    connect(api, &TelegramApi::authResetAuthorizationsError, this, &TelegramCore::onAuthResetAuthorizationsError);
    
    connect(api, &TelegramApi::authSendInvitesAnswer, this, &TelegramCore::onAuthSendInvitesAnswer);
    connect(api, &TelegramApi::authSendInvitesError, this, &TelegramCore::onAuthSendInvitesError);
    
    connect(api, &TelegramApi::authExportAuthorizationAnswer, this, &TelegramCore::onAuthExportAuthorizationAnswer);
    connect(api, &TelegramApi::authExportAuthorizationError, this, &TelegramCore::onAuthExportAuthorizationError);
    
    connect(api, &TelegramApi::authImportAuthorizationAnswer, this, &TelegramCore::onAuthImportAuthorizationAnswer);
    connect(api, &TelegramApi::authImportAuthorizationError, this, &TelegramCore::onAuthImportAuthorizationError);
    
    connect(api, &TelegramApi::authBindTempAuthKeyAnswer, this, &TelegramCore::onAuthBindTempAuthKeyAnswer);
    connect(api, &TelegramApi::authBindTempAuthKeyError, this, &TelegramCore::onAuthBindTempAuthKeyError);
    
    connect(api, &TelegramApi::authSendSmsAnswer, this, &TelegramCore::onAuthSendSmsAnswer);
    connect(api, &TelegramApi::authSendSmsError, this, &TelegramCore::onAuthSendSmsError);
    
    connect(api, &TelegramApi::authCheckPasswordAnswer, this, &TelegramCore::onAuthCheckPasswordAnswer);
    connect(api, &TelegramApi::authCheckPasswordError, this, &TelegramCore::onAuthCheckPasswordError);
    
    connect(api, &TelegramApi::authRequestPasswordRecoveryAnswer, this, &TelegramCore::onAuthRequestPasswordRecoveryAnswer);
    connect(api, &TelegramApi::authRequestPasswordRecoveryError, this, &TelegramCore::onAuthRequestPasswordRecoveryError);
    
    connect(api, &TelegramApi::authRecoverPasswordAnswer, this, &TelegramCore::onAuthRecoverPasswordAnswer);
    connect(api, &TelegramApi::authRecoverPasswordError, this, &TelegramCore::onAuthRecoverPasswordError);
    
    
    connect(api, &TelegramApi::contactsGetStatusesAnswer, this, &TelegramCore::onContactsGetStatusesAnswer);
    connect(api, &TelegramApi::contactsGetStatusesError, this, &TelegramCore::onContactsGetStatusesError);
    
    connect(api, &TelegramApi::contactsGetContactsAnswer, this, &TelegramCore::onContactsGetContactsAnswer);
    connect(api, &TelegramApi::contactsGetContactsError, this, &TelegramCore::onContactsGetContactsError);
    
    connect(api, &TelegramApi::contactsImportContactsAnswer, this, &TelegramCore::onContactsImportContactsAnswer);
    connect(api, &TelegramApi::contactsImportContactsError, this, &TelegramCore::onContactsImportContactsError);
    
    connect(api, &TelegramApi::contactsGetSuggestedAnswer, this, &TelegramCore::onContactsGetSuggestedAnswer);
    connect(api, &TelegramApi::contactsGetSuggestedError, this, &TelegramCore::onContactsGetSuggestedError);
    
    connect(api, &TelegramApi::contactsDeleteContactAnswer, this, &TelegramCore::onContactsDeleteContactAnswer);
    connect(api, &TelegramApi::contactsDeleteContactError, this, &TelegramCore::onContactsDeleteContactError);
    
    connect(api, &TelegramApi::contactsDeleteContactsAnswer, this, &TelegramCore::onContactsDeleteContactsAnswer);
    connect(api, &TelegramApi::contactsDeleteContactsError, this, &TelegramCore::onContactsDeleteContactsError);
    
    connect(api, &TelegramApi::contactsBlockAnswer, this, &TelegramCore::onContactsBlockAnswer);
    connect(api, &TelegramApi::contactsBlockError, this, &TelegramCore::onContactsBlockError);
    
    connect(api, &TelegramApi::contactsUnblockAnswer, this, &TelegramCore::onContactsUnblockAnswer);
    connect(api, &TelegramApi::contactsUnblockError, this, &TelegramCore::onContactsUnblockError);
    
    connect(api, &TelegramApi::contactsGetBlockedAnswer, this, &TelegramCore::onContactsGetBlockedAnswer);
    connect(api, &TelegramApi::contactsGetBlockedError, this, &TelegramCore::onContactsGetBlockedError);
    
    connect(api, &TelegramApi::contactsExportCardAnswer, this, &TelegramCore::onContactsExportCardAnswer);
    connect(api, &TelegramApi::contactsExportCardError, this, &TelegramCore::onContactsExportCardError);
    
    connect(api, &TelegramApi::contactsImportCardAnswer, this, &TelegramCore::onContactsImportCardAnswer);
    connect(api, &TelegramApi::contactsImportCardError, this, &TelegramCore::onContactsImportCardError);
    
    connect(api, &TelegramApi::contactsSearchAnswer, this, &TelegramCore::onContactsSearchAnswer);
    connect(api, &TelegramApi::contactsSearchError, this, &TelegramCore::onContactsSearchError);
    
    connect(api, &TelegramApi::contactsResolveUsernameAnswer, this, &TelegramCore::onContactsResolveUsernameAnswer);
    connect(api, &TelegramApi::contactsResolveUsernameError, this, &TelegramCore::onContactsResolveUsernameError);
    
    
    connect(api, &TelegramApi::geochatsGetLocatedAnswer, this, &TelegramCore::onGeochatsGetLocatedAnswer);
    connect(api, &TelegramApi::geochatsGetLocatedError, this, &TelegramCore::onGeochatsGetLocatedError);
    
    connect(api, &TelegramApi::geochatsGetRecentsAnswer, this, &TelegramCore::onGeochatsGetRecentsAnswer);
    connect(api, &TelegramApi::geochatsGetRecentsError, this, &TelegramCore::onGeochatsGetRecentsError);
    
    connect(api, &TelegramApi::geochatsCheckinAnswer, this, &TelegramCore::onGeochatsCheckinAnswer);
    connect(api, &TelegramApi::geochatsCheckinError, this, &TelegramCore::onGeochatsCheckinError);
    
    connect(api, &TelegramApi::geochatsGetFullChatAnswer, this, &TelegramCore::onGeochatsGetFullChatAnswer);
    connect(api, &TelegramApi::geochatsGetFullChatError, this, &TelegramCore::onGeochatsGetFullChatError);
    
    connect(api, &TelegramApi::geochatsEditChatTitleAnswer, this, &TelegramCore::onGeochatsEditChatTitleAnswer);
    connect(api, &TelegramApi::geochatsEditChatTitleError, this, &TelegramCore::onGeochatsEditChatTitleError);
    
    connect(api, &TelegramApi::geochatsEditChatPhotoAnswer, this, &TelegramCore::onGeochatsEditChatPhotoAnswer);
    connect(api, &TelegramApi::geochatsEditChatPhotoError, this, &TelegramCore::onGeochatsEditChatPhotoError);
    
    connect(api, &TelegramApi::geochatsSearchAnswer, this, &TelegramCore::onGeochatsSearchAnswer);
    connect(api, &TelegramApi::geochatsSearchError, this, &TelegramCore::onGeochatsSearchError);
    
    connect(api, &TelegramApi::geochatsGetHistoryAnswer, this, &TelegramCore::onGeochatsGetHistoryAnswer);
    connect(api, &TelegramApi::geochatsGetHistoryError, this, &TelegramCore::onGeochatsGetHistoryError);
    
    connect(api, &TelegramApi::geochatsSetTypingAnswer, this, &TelegramCore::onGeochatsSetTypingAnswer);
    connect(api, &TelegramApi::geochatsSetTypingError, this, &TelegramCore::onGeochatsSetTypingError);
    
    connect(api, &TelegramApi::geochatsSendMessageAnswer, this, &TelegramCore::onGeochatsSendMessageAnswer);
    connect(api, &TelegramApi::geochatsSendMessageError, this, &TelegramCore::onGeochatsSendMessageError);
    
    connect(api, &TelegramApi::geochatsSendMediaAnswer, this, &TelegramCore::onGeochatsSendMediaAnswer);
    connect(api, &TelegramApi::geochatsSendMediaError, this, &TelegramCore::onGeochatsSendMediaError);
    
    connect(api, &TelegramApi::geochatsCreateGeoChatAnswer, this, &TelegramCore::onGeochatsCreateGeoChatAnswer);
    connect(api, &TelegramApi::geochatsCreateGeoChatError, this, &TelegramCore::onGeochatsCreateGeoChatError);
    
    
    connect(api, &TelegramApi::helpGetConfigAnswer, this, &TelegramCore::onHelpGetConfigAnswer);
    connect(api, &TelegramApi::helpGetConfigError, this, &TelegramCore::onHelpGetConfigError);
    
    connect(api, &TelegramApi::helpGetNearestDcAnswer, this, &TelegramCore::onHelpGetNearestDcAnswer);
    connect(api, &TelegramApi::helpGetNearestDcError, this, &TelegramCore::onHelpGetNearestDcError);
    
    connect(api, &TelegramApi::helpGetAppUpdateAnswer, this, &TelegramCore::onHelpGetAppUpdateAnswer);
    connect(api, &TelegramApi::helpGetAppUpdateError, this, &TelegramCore::onHelpGetAppUpdateError);
    
    connect(api, &TelegramApi::helpSaveAppLogAnswer, this, &TelegramCore::onHelpSaveAppLogAnswer);
    connect(api, &TelegramApi::helpSaveAppLogError, this, &TelegramCore::onHelpSaveAppLogError);
    
    connect(api, &TelegramApi::helpGetInviteTextAnswer, this, &TelegramCore::onHelpGetInviteTextAnswer);
    connect(api, &TelegramApi::helpGetInviteTextError, this, &TelegramCore::onHelpGetInviteTextError);
    
    connect(api, &TelegramApi::helpGetSupportAnswer, this, &TelegramCore::onHelpGetSupportAnswer);
    connect(api, &TelegramApi::helpGetSupportError, this, &TelegramCore::onHelpGetSupportError);
    
    
    connect(api, &TelegramApi::messagesStartBotAnswer, this, &TelegramCore::onMessagesStartBotAnswer);
    connect(api, &TelegramApi::messagesStartBotError, this, &TelegramCore::onMessagesStartBotError);
    
    connect(api, &TelegramApi::messagesGetMessagesAnswer, this, &TelegramCore::onMessagesGetMessagesAnswer);
    connect(api, &TelegramApi::messagesGetMessagesError, this, &TelegramCore::onMessagesGetMessagesError);
    
    connect(api, &TelegramApi::messagesGetDialogsAnswer, this, &TelegramCore::onMessagesGetDialogsAnswer);
    connect(api, &TelegramApi::messagesGetDialogsError, this, &TelegramCore::onMessagesGetDialogsError);
    
    connect(api, &TelegramApi::messagesGetHistoryAnswer, this, &TelegramCore::onMessagesGetHistoryAnswer);
    connect(api, &TelegramApi::messagesGetHistoryError, this, &TelegramCore::onMessagesGetHistoryError);
    
    connect(api, &TelegramApi::messagesSearchAnswer, this, &TelegramCore::onMessagesSearchAnswer);
    connect(api, &TelegramApi::messagesSearchError, this, &TelegramCore::onMessagesSearchError);
    
    connect(api, &TelegramApi::messagesReadHistoryAnswer, this, &TelegramCore::onMessagesReadHistoryAnswer);
    connect(api, &TelegramApi::messagesReadHistoryError, this, &TelegramCore::onMessagesReadHistoryError);
    
    connect(api, &TelegramApi::messagesDeleteHistoryAnswer, this, &TelegramCore::onMessagesDeleteHistoryAnswer);
    connect(api, &TelegramApi::messagesDeleteHistoryError, this, &TelegramCore::onMessagesDeleteHistoryError);
    
    connect(api, &TelegramApi::messagesDeleteMessagesAnswer, this, &TelegramCore::onMessagesDeleteMessagesAnswer);
    connect(api, &TelegramApi::messagesDeleteMessagesError, this, &TelegramCore::onMessagesDeleteMessagesError);
    
    connect(api, &TelegramApi::messagesReceivedMessagesAnswer, this, &TelegramCore::onMessagesReceivedMessagesAnswer);
    connect(api, &TelegramApi::messagesReceivedMessagesError, this, &TelegramCore::onMessagesReceivedMessagesError);
    
    connect(api, &TelegramApi::messagesSetTypingAnswer, this, &TelegramCore::onMessagesSetTypingAnswer);
    connect(api, &TelegramApi::messagesSetTypingError, this, &TelegramCore::onMessagesSetTypingError);
    
    connect(api, &TelegramApi::messagesSendMessageAnswer, this, &TelegramCore::onMessagesSendMessageAnswer);
    connect(api, &TelegramApi::messagesSendMessageError, this, &TelegramCore::onMessagesSendMessageError);
    
    connect(api, &TelegramApi::messagesSendMediaAnswer, this, &TelegramCore::onMessagesSendMediaAnswer);
    connect(api, &TelegramApi::messagesSendMediaError, this, &TelegramCore::onMessagesSendMediaError);
    
    connect(api, &TelegramApi::messagesForwardMessagesAnswer, this, &TelegramCore::onMessagesForwardMessagesAnswer);
    connect(api, &TelegramApi::messagesForwardMessagesError, this, &TelegramCore::onMessagesForwardMessagesError);
    
    connect(api, &TelegramApi::messagesGetChatsAnswer, this, &TelegramCore::onMessagesGetChatsAnswer);
    connect(api, &TelegramApi::messagesGetChatsError, this, &TelegramCore::onMessagesGetChatsError);
    
    connect(api, &TelegramApi::messagesGetFullChatAnswer, this, &TelegramCore::onMessagesGetFullChatAnswer);
    connect(api, &TelegramApi::messagesGetFullChatError, this, &TelegramCore::onMessagesGetFullChatError);
    
    connect(api, &TelegramApi::messagesEditChatTitleAnswer, this, &TelegramCore::onMessagesEditChatTitleAnswer);
    connect(api, &TelegramApi::messagesEditChatTitleError, this, &TelegramCore::onMessagesEditChatTitleError);
    
    connect(api, &TelegramApi::messagesEditChatPhotoAnswer, this, &TelegramCore::onMessagesEditChatPhotoAnswer);
    connect(api, &TelegramApi::messagesEditChatPhotoError, this, &TelegramCore::onMessagesEditChatPhotoError);
    
    connect(api, &TelegramApi::messagesAddChatUserAnswer, this, &TelegramCore::onMessagesAddChatUserAnswer);
    connect(api, &TelegramApi::messagesAddChatUserError, this, &TelegramCore::onMessagesAddChatUserError);
    
    connect(api, &TelegramApi::messagesDeleteChatUserAnswer, this, &TelegramCore::onMessagesDeleteChatUserAnswer);
    connect(api, &TelegramApi::messagesDeleteChatUserError, this, &TelegramCore::onMessagesDeleteChatUserError);
    
    connect(api, &TelegramApi::messagesCreateChatAnswer, this, &TelegramCore::onMessagesCreateChatAnswer);
    connect(api, &TelegramApi::messagesCreateChatError, this, &TelegramCore::onMessagesCreateChatError);
    
    connect(api, &TelegramApi::messagesForwardMessageAnswer, this, &TelegramCore::onMessagesForwardMessageAnswer);
    connect(api, &TelegramApi::messagesForwardMessageError, this, &TelegramCore::onMessagesForwardMessageError);
    
    connect(api, &TelegramApi::messagesSendBroadcastAnswer, this, &TelegramCore::onMessagesSendBroadcastAnswer);
    connect(api, &TelegramApi::messagesSendBroadcastError, this, &TelegramCore::onMessagesSendBroadcastError);
    
    connect(api, &TelegramApi::messagesGetDhConfigAnswer, this, &TelegramCore::onMessagesGetDhConfigAnswer);
    connect(api, &TelegramApi::messagesGetDhConfigError, this, &TelegramCore::onMessagesGetDhConfigError);
    
    connect(api, &TelegramApi::messagesRequestEncryptionAnswer, this, &TelegramCore::onMessagesRequestEncryptionAnswer);
    connect(api, &TelegramApi::messagesRequestEncryptionError, this, &TelegramCore::onMessagesRequestEncryptionError);
    
    connect(api, &TelegramApi::messagesAcceptEncryptionAnswer, this, &TelegramCore::onMessagesAcceptEncryptionAnswer);
    connect(api, &TelegramApi::messagesAcceptEncryptionError, this, &TelegramCore::onMessagesAcceptEncryptionError);
    
    connect(api, &TelegramApi::messagesDiscardEncryptionAnswer, this, &TelegramCore::onMessagesDiscardEncryptionAnswer);
    connect(api, &TelegramApi::messagesDiscardEncryptionError, this, &TelegramCore::onMessagesDiscardEncryptionError);
    
    connect(api, &TelegramApi::messagesSetEncryptedTypingAnswer, this, &TelegramCore::onMessagesSetEncryptedTypingAnswer);
    connect(api, &TelegramApi::messagesSetEncryptedTypingError, this, &TelegramCore::onMessagesSetEncryptedTypingError);
    
    connect(api, &TelegramApi::messagesReadEncryptedHistoryAnswer, this, &TelegramCore::onMessagesReadEncryptedHistoryAnswer);
    connect(api, &TelegramApi::messagesReadEncryptedHistoryError, this, &TelegramCore::onMessagesReadEncryptedHistoryError);
    
    connect(api, &TelegramApi::messagesSendEncryptedAnswer, this, &TelegramCore::onMessagesSendEncryptedAnswer);
    connect(api, &TelegramApi::messagesSendEncryptedError, this, &TelegramCore::onMessagesSendEncryptedError);
    
    connect(api, &TelegramApi::messagesSendEncryptedFileAnswer, this, &TelegramCore::onMessagesSendEncryptedFileAnswer);
    connect(api, &TelegramApi::messagesSendEncryptedFileError, this, &TelegramCore::onMessagesSendEncryptedFileError);
    
    connect(api, &TelegramApi::messagesSendEncryptedServiceAnswer, this, &TelegramCore::onMessagesSendEncryptedServiceAnswer);
    connect(api, &TelegramApi::messagesSendEncryptedServiceError, this, &TelegramCore::onMessagesSendEncryptedServiceError);
    
    connect(api, &TelegramApi::messagesReceivedQueueAnswer, this, &TelegramCore::onMessagesReceivedQueueAnswer);
    connect(api, &TelegramApi::messagesReceivedQueueError, this, &TelegramCore::onMessagesReceivedQueueError);
    
    connect(api, &TelegramApi::messagesReadMessageContentsAnswer, this, &TelegramCore::onMessagesReadMessageContentsAnswer);
    connect(api, &TelegramApi::messagesReadMessageContentsError, this, &TelegramCore::onMessagesReadMessageContentsError);
    
    connect(api, &TelegramApi::messagesGetStickersAnswer, this, &TelegramCore::onMessagesGetStickersAnswer);
    connect(api, &TelegramApi::messagesGetStickersError, this, &TelegramCore::onMessagesGetStickersError);
    
    connect(api, &TelegramApi::messagesGetAllStickersAnswer, this, &TelegramCore::onMessagesGetAllStickersAnswer);
    connect(api, &TelegramApi::messagesGetAllStickersError, this, &TelegramCore::onMessagesGetAllStickersError);
    
    connect(api, &TelegramApi::messagesGetWebPagePreviewAnswer, this, &TelegramCore::onMessagesGetWebPagePreviewAnswer);
    connect(api, &TelegramApi::messagesGetWebPagePreviewError, this, &TelegramCore::onMessagesGetWebPagePreviewError);
    
    connect(api, &TelegramApi::messagesExportChatInviteAnswer, this, &TelegramCore::onMessagesExportChatInviteAnswer);
    connect(api, &TelegramApi::messagesExportChatInviteError, this, &TelegramCore::onMessagesExportChatInviteError);
    
    connect(api, &TelegramApi::messagesCheckChatInviteAnswer, this, &TelegramCore::onMessagesCheckChatInviteAnswer);
    connect(api, &TelegramApi::messagesCheckChatInviteError, this, &TelegramCore::onMessagesCheckChatInviteError);
    
    connect(api, &TelegramApi::messagesImportChatInviteAnswer, this, &TelegramCore::onMessagesImportChatInviteAnswer);
    connect(api, &TelegramApi::messagesImportChatInviteError, this, &TelegramCore::onMessagesImportChatInviteError);
    
    connect(api, &TelegramApi::messagesGetStickerSetAnswer, this, &TelegramCore::onMessagesGetStickerSetAnswer);
    connect(api, &TelegramApi::messagesGetStickerSetError, this, &TelegramCore::onMessagesGetStickerSetError);
    
    connect(api, &TelegramApi::messagesInstallStickerSetAnswer, this, &TelegramCore::onMessagesInstallStickerSetAnswer);
    connect(api, &TelegramApi::messagesInstallStickerSetError, this, &TelegramCore::onMessagesInstallStickerSetError);
    
    connect(api, &TelegramApi::messagesUninstallStickerSetAnswer, this, &TelegramCore::onMessagesUninstallStickerSetAnswer);
    connect(api, &TelegramApi::messagesUninstallStickerSetError, this, &TelegramCore::onMessagesUninstallStickerSetError);
    
    
    connect(api, &TelegramApi::photosUpdateProfilePhotoAnswer, this, &TelegramCore::onPhotosUpdateProfilePhotoAnswer);
    connect(api, &TelegramApi::photosUpdateProfilePhotoError, this, &TelegramCore::onPhotosUpdateProfilePhotoError);
    
    connect(api, &TelegramApi::photosUploadProfilePhotoAnswer, this, &TelegramCore::onPhotosUploadProfilePhotoAnswer);
    connect(api, &TelegramApi::photosUploadProfilePhotoError, this, &TelegramCore::onPhotosUploadProfilePhotoError);
    
    connect(api, &TelegramApi::photosDeletePhotosAnswer, this, &TelegramCore::onPhotosDeletePhotosAnswer);
    connect(api, &TelegramApi::photosDeletePhotosError, this, &TelegramCore::onPhotosDeletePhotosError);
    
    connect(api, &TelegramApi::photosGetUserPhotosAnswer, this, &TelegramCore::onPhotosGetUserPhotosAnswer);
    connect(api, &TelegramApi::photosGetUserPhotosError, this, &TelegramCore::onPhotosGetUserPhotosError);
    
    
    connect(api, &TelegramApi::updatesGetStateAnswer, this, &TelegramCore::onUpdatesGetStateAnswer);
    connect(api, &TelegramApi::updatesGetStateError, this, &TelegramCore::onUpdatesGetStateError);
    
    connect(api, &TelegramApi::updatesGetDifferenceAnswer, this, &TelegramCore::onUpdatesGetDifferenceAnswer);
    connect(api, &TelegramApi::updatesGetDifferenceError, this, &TelegramCore::onUpdatesGetDifferenceError);
    
    
    connect(api, &TelegramApi::uploadSaveFilePartAnswer, this, &TelegramCore::onUploadSaveFilePartAnswer);
    connect(api, &TelegramApi::uploadSaveFilePartError, this, &TelegramCore::onUploadSaveFilePartError);
    
    connect(api, &TelegramApi::uploadGetFileAnswer, this, &TelegramCore::onUploadGetFileAnswer);
    connect(api, &TelegramApi::uploadGetFileError, this, &TelegramCore::onUploadGetFileError);
    
    connect(api, &TelegramApi::uploadSaveBigFilePartAnswer, this, &TelegramCore::onUploadSaveBigFilePartAnswer);
    connect(api, &TelegramApi::uploadSaveBigFilePartError, this, &TelegramCore::onUploadSaveBigFilePartError);
    
    
    connect(api, &TelegramApi::usersGetUsersAnswer, this, &TelegramCore::onUsersGetUsersAnswer);
    connect(api, &TelegramApi::usersGetUsersError, this, &TelegramCore::onUsersGetUsersError);
    
    connect(api, &TelegramApi::usersGetFullUserAnswer, this, &TelegramCore::onUsersGetFullUserAnswer);
    connect(api, &TelegramApi::usersGetFullUserError, this, &TelegramCore::onUsersGetFullUserError);

    connect(api, &TelegramApi::error, this, &TelegramCore::onError);
}

qint64 TelegramCore::accountRegisterDevice(qint32 token_type, const QString &token, const QString &device_model, const QString &system_version, const QString &app_version, bool app_sandbox, const QString &lang_code, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountRegisterDevice(token_type, token, device_model, system_version, app_version, app_sandbox, lang_code);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountRegisterDevice";
        mRecallArgs[msgId]["token_type"] = QVariant::fromValue<qint32>(token_type);
        mRecallArgs[msgId]["token"] = QVariant::fromValue<QString>(token);
        mRecallArgs[msgId]["device_model"] = QVariant::fromValue<QString>(device_model);
        mRecallArgs[msgId]["system_version"] = QVariant::fromValue<QString>(system_version);
        mRecallArgs[msgId]["app_version"] = QVariant::fromValue<QString>(app_version);
        mRecallArgs[msgId]["app_sandbox"] = QVariant::fromValue<bool>(app_sandbox);
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountRegisterDeviceAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountRegisterDeviceAnswer(msgId, result);
}

void TelegramCore::onAccountRegisterDeviceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountRegisterDeviceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUnregisterDevice(qint32 token_type, const QString &token, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUnregisterDevice(token_type, token);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUnregisterDevice";
        mRecallArgs[msgId]["token_type"] = QVariant::fromValue<qint32>(token_type);
        mRecallArgs[msgId]["token"] = QVariant::fromValue<QString>(token);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUnregisterDeviceAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUnregisterDeviceAnswer(msgId, result);
}

void TelegramCore::onAccountUnregisterDeviceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUnregisterDeviceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateNotifySettings(const InputNotifyPeer &peer, const InputPeerNotifySettings &settings, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateNotifySettings(peer, settings);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateNotifySettings";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputNotifyPeer>(peer);
        mRecallArgs[msgId]["settings"] = QVariant::fromValue<InputPeerNotifySettings>(settings);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateNotifySettingsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateNotifySettingsAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateNotifySettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateNotifySettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetNotifySettings(const InputNotifyPeer &peer, Callback<PeerNotifySettings > callBack, qint32 timeout) {
    if(!mApi) {
        const PeerNotifySettings &result = PeerNotifySettings();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetNotifySettings(peer);
    if(msgId) {
        callBackPush<PeerNotifySettings >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetNotifySettings";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputNotifyPeer>(peer);
    } else {
        const PeerNotifySettings &result = PeerNotifySettings();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetNotifySettingsAnswer(qint64 msgId, const PeerNotifySettings &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<PeerNotifySettings >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetNotifySettingsAnswer(msgId, result);
}

void TelegramCore::onAccountGetNotifySettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const PeerNotifySettings &result = PeerNotifySettings();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<PeerNotifySettings >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetNotifySettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountResetNotifySettings(Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountResetNotifySettings();
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountResetNotifySettings";
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountResetNotifySettingsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountResetNotifySettingsAnswer(msgId, result);
}

void TelegramCore::onAccountResetNotifySettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountResetNotifySettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateProfile(const QString &first_name, const QString &last_name, Callback<User > callBack, qint32 timeout) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateProfile(first_name, last_name);
    if(msgId) {
        callBackPush<User >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateProfile";
        mRecallArgs[msgId]["first_name"] = QVariant::fromValue<QString>(first_name);
        mRecallArgs[msgId]["last_name"] = QVariant::fromValue<QString>(last_name);
    } else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateProfileAnswer(qint64 msgId, const User &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<User >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateProfileAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateProfileError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateProfileError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateStatus(bool offline, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateStatus(offline);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateStatus";
        mRecallArgs[msgId]["offline"] = QVariant::fromValue<bool>(offline);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateStatusAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateStatusAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateStatusError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateStatusError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetWallPapers(Callback<QList<WallPaper> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<WallPaper> &result = QList<WallPaper>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetWallPapers();
    if(msgId) {
        callBackPush<QList<WallPaper> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetWallPapers";
    } else {
        const QList<WallPaper> &result = QList<WallPaper>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetWallPapersAnswer(qint64 msgId, const QList<WallPaper> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<QList<WallPaper> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetWallPapersAnswer(msgId, result);
}

void TelegramCore::onAccountGetWallPapersError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const QList<WallPaper> &result = QList<WallPaper>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<WallPaper> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetWallPapersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountCheckUsername(const QString &username, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountCheckUsername(username);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountCheckUsername";
        mRecallArgs[msgId]["username"] = QVariant::fromValue<QString>(username);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountCheckUsernameAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountCheckUsernameAnswer(msgId, result);
}

void TelegramCore::onAccountCheckUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountCheckUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateUsername(const QString &username, Callback<User > callBack, qint32 timeout) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateUsername(username);
    if(msgId) {
        callBackPush<User >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateUsername";
        mRecallArgs[msgId]["username"] = QVariant::fromValue<QString>(username);
    } else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateUsernameAnswer(qint64 msgId, const User &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<User >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateUsernameAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetPrivacy(const InputPrivacyKey &key, Callback<AccountPrivacyRules > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetPrivacy(key);
    if(msgId) {
        callBackPush<AccountPrivacyRules >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetPrivacy";
        mRecallArgs[msgId]["key"] = QVariant::fromValue<InputPrivacyKey>(key);
    } else {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetPrivacyAnswer(qint64 msgId, const AccountPrivacyRules &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AccountPrivacyRules >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetPrivacyAnswer(msgId, result);
}

void TelegramCore::onAccountGetPrivacyError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AccountPrivacyRules &result = AccountPrivacyRules();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPrivacyRules >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetPrivacyError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountSetPrivacy(const InputPrivacyKey &key, const QList<InputPrivacyRule> &rules, Callback<AccountPrivacyRules > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountSetPrivacy(key, rules);
    if(msgId) {
        callBackPush<AccountPrivacyRules >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountSetPrivacy";
        mRecallArgs[msgId]["key"] = QVariant::fromValue<InputPrivacyKey>(key);
        mRecallArgs[msgId]["rules"] = QVariant::fromValue<QList<InputPrivacyRule>>(rules);
    } else {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountSetPrivacyAnswer(qint64 msgId, const AccountPrivacyRules &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AccountPrivacyRules >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountSetPrivacyAnswer(msgId, result);
}

void TelegramCore::onAccountSetPrivacyError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AccountPrivacyRules &result = AccountPrivacyRules();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPrivacyRules >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountSetPrivacyError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountDeleteAccount(const QString &reason, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountDeleteAccount(reason);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountDeleteAccount";
        mRecallArgs[msgId]["reason"] = QVariant::fromValue<QString>(reason);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountDeleteAccountAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountDeleteAccountAnswer(msgId, result);
}

void TelegramCore::onAccountDeleteAccountError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountDeleteAccountError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetAccountTTL(Callback<AccountDaysTTL > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountDaysTTL &result = AccountDaysTTL();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetAccountTTL();
    if(msgId) {
        callBackPush<AccountDaysTTL >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetAccountTTL";
    } else {
        const AccountDaysTTL &result = AccountDaysTTL();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetAccountTTLAnswer(qint64 msgId, const AccountDaysTTL &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AccountDaysTTL >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetAccountTTLAnswer(msgId, result);
}

void TelegramCore::onAccountGetAccountTTLError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AccountDaysTTL &result = AccountDaysTTL();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountDaysTTL >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetAccountTTLError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountSetAccountTTL(const AccountDaysTTL &ttl, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountSetAccountTTL(ttl);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountSetAccountTTL";
        mRecallArgs[msgId]["ttl"] = QVariant::fromValue<AccountDaysTTL>(ttl);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountSetAccountTTLAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountSetAccountTTLAnswer(msgId, result);
}

void TelegramCore::onAccountSetAccountTTLError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountSetAccountTTLError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountSendChangePhoneCode(const QString &phone_number, Callback<AccountSentChangePhoneCode > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountSentChangePhoneCode &result = AccountSentChangePhoneCode();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountSendChangePhoneCode(phone_number);
    if(msgId) {
        callBackPush<AccountSentChangePhoneCode >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountSendChangePhoneCode";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
    } else {
        const AccountSentChangePhoneCode &result = AccountSentChangePhoneCode();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountSendChangePhoneCodeAnswer(qint64 msgId, const AccountSentChangePhoneCode &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AccountSentChangePhoneCode >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountSendChangePhoneCodeAnswer(msgId, result);
}

void TelegramCore::onAccountSendChangePhoneCodeError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AccountSentChangePhoneCode &result = AccountSentChangePhoneCode();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountSentChangePhoneCode >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountSendChangePhoneCodeError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountChangePhone(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, Callback<User > callBack, qint32 timeout) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountChangePhone(phone_number, phone_code_hash, phone_code);
    if(msgId) {
        callBackPush<User >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountChangePhone";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
        mRecallArgs[msgId]["phone_code"] = QVariant::fromValue<QString>(phone_code);
    } else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountChangePhoneAnswer(qint64 msgId, const User &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<User >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountChangePhoneAnswer(msgId, result);
}

void TelegramCore::onAccountChangePhoneError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountChangePhoneError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateDeviceLocked(qint32 period, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateDeviceLocked(period);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateDeviceLocked";
        mRecallArgs[msgId]["period"] = QVariant::fromValue<qint32>(period);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateDeviceLockedAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateDeviceLockedAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateDeviceLockedError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateDeviceLockedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetAuthorizations(Callback<AccountAuthorizations > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountAuthorizations &result = AccountAuthorizations();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetAuthorizations();
    if(msgId) {
        callBackPush<AccountAuthorizations >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetAuthorizations";
    } else {
        const AccountAuthorizations &result = AccountAuthorizations();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetAuthorizationsAnswer(qint64 msgId, const AccountAuthorizations &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AccountAuthorizations >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetAuthorizationsAnswer(msgId, result);
}

void TelegramCore::onAccountGetAuthorizationsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AccountAuthorizations &result = AccountAuthorizations();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountAuthorizations >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetAuthorizationsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountResetAuthorization(qint64 hash, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountResetAuthorization(hash);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountResetAuthorization";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<qint64>(hash);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountResetAuthorizationAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountResetAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAccountResetAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountResetAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetPassword(Callback<AccountPassword > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountPassword &result = AccountPassword();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetPassword();
    if(msgId) {
        callBackPush<AccountPassword >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetPassword";
    } else {
        const AccountPassword &result = AccountPassword();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetPasswordAnswer(qint64 msgId, const AccountPassword &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AccountPassword >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetPasswordAnswer(msgId, result);
}

void TelegramCore::onAccountGetPasswordError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AccountPassword &result = AccountPassword();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPassword >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetPasswordError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetPasswordSettings(const QByteArray &current_password_hash, Callback<AccountPasswordSettings > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountPasswordSettings &result = AccountPasswordSettings();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetPasswordSettings(current_password_hash);
    if(msgId) {
        callBackPush<AccountPasswordSettings >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetPasswordSettings";
        mRecallArgs[msgId]["current_password_hash"] = QVariant::fromValue<QByteArray>(current_password_hash);
    } else {
        const AccountPasswordSettings &result = AccountPasswordSettings();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetPasswordSettingsAnswer(qint64 msgId, const AccountPasswordSettings &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AccountPasswordSettings >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetPasswordSettingsAnswer(msgId, result);
}

void TelegramCore::onAccountGetPasswordSettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AccountPasswordSettings &result = AccountPasswordSettings();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPasswordSettings >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetPasswordSettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdatePasswordSettings(const QByteArray &current_password_hash, const AccountPasswordInputSettings &new_settings, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdatePasswordSettings(current_password_hash, new_settings);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdatePasswordSettings";
        mRecallArgs[msgId]["current_password_hash"] = QVariant::fromValue<QByteArray>(current_password_hash);
        mRecallArgs[msgId]["new_settings"] = QVariant::fromValue<AccountPasswordInputSettings>(new_settings);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdatePasswordSettingsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdatePasswordSettingsAnswer(msgId, result);
}

void TelegramCore::onAccountUpdatePasswordSettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdatePasswordSettingsError(msgId, errorCode, errorText);
}


qint64 TelegramCore::authImportBotAuthorization(qint32 flags, qint32 api_id, const QString &api_hash, const QString &bot_auth_token, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authImportBotAuthorization(flags, api_id, api_hash, bot_auth_token);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authImportBotAuthorization";
        mRecallArgs[msgId]["flags"] = QVariant::fromValue<qint32>(flags);
        mRecallArgs[msgId]["api_id"] = QVariant::fromValue<qint32>(api_id);
        mRecallArgs[msgId]["api_hash"] = QVariant::fromValue<QString>(api_hash);
        mRecallArgs[msgId]["bot_auth_token"] = QVariant::fromValue<QString>(bot_auth_token);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthImportBotAuthorizationAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authImportBotAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAuthImportBotAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authImportBotAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authCheckPhone(const QString &phone_number, Callback<AuthCheckedPhone > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthCheckedPhone &result = AuthCheckedPhone();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authCheckPhone(phone_number);
    if(msgId) {
        callBackPush<AuthCheckedPhone >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authCheckPhone";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
    } else {
        const AuthCheckedPhone &result = AuthCheckedPhone();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthCheckPhoneAnswer(qint64 msgId, const AuthCheckedPhone &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthCheckedPhone >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authCheckPhoneAnswer(msgId, result);
}

void TelegramCore::onAuthCheckPhoneError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthCheckedPhone &result = AuthCheckedPhone();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthCheckedPhone >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authCheckPhoneError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendCode(const QString &phone_number, qint32 sms_type, qint32 api_id, const QString &api_hash, const QString &lang_code, Callback<AuthSentCode > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthSentCode &result = AuthSentCode();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendCode(phone_number, sms_type, api_id, api_hash, lang_code);
    if(msgId) {
        callBackPush<AuthSentCode >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSendCode";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["sms_type"] = QVariant::fromValue<qint32>(sms_type);
        mRecallArgs[msgId]["api_id"] = QVariant::fromValue<qint32>(api_id);
        mRecallArgs[msgId]["api_hash"] = QVariant::fromValue<QString>(api_hash);
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        const AuthSentCode &result = AuthSentCode();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendCodeAnswer(qint64 msgId, const AuthSentCode &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthSentCode >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSendCodeAnswer(msgId, result);
}

void TelegramCore::onAuthSendCodeError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthSentCode &result = AuthSentCode();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthSentCode >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSendCodeError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendCall(const QString &phone_number, const QString &phone_code_hash, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendCall(phone_number, phone_code_hash);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSendCall";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendCallAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSendCallAnswer(msgId, result);
}

void TelegramCore::onAuthSendCallError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSendCallError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSignUp(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, const QString &first_name, const QString &last_name, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSignUp(phone_number, phone_code_hash, phone_code, first_name, last_name);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSignUp";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
        mRecallArgs[msgId]["phone_code"] = QVariant::fromValue<QString>(phone_code);
        mRecallArgs[msgId]["first_name"] = QVariant::fromValue<QString>(first_name);
        mRecallArgs[msgId]["last_name"] = QVariant::fromValue<QString>(last_name);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSignUpAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSignUpAnswer(msgId, result);
}

void TelegramCore::onAuthSignUpError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSignUpError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSignIn(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSignIn(phone_number, phone_code_hash, phone_code);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSignIn";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
        mRecallArgs[msgId]["phone_code"] = QVariant::fromValue<QString>(phone_code);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSignInAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSignInAnswer(msgId, result);
}

void TelegramCore::onAuthSignInError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSignInError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authLogOut(Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authLogOut();
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authLogOut";
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthLogOutAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authLogOutAnswer(msgId, result);
}

void TelegramCore::onAuthLogOutError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authLogOutError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authResetAuthorizations(Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authResetAuthorizations();
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authResetAuthorizations";
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthResetAuthorizationsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authResetAuthorizationsAnswer(msgId, result);
}

void TelegramCore::onAuthResetAuthorizationsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authResetAuthorizationsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendInvites(const QList<QString> &phone_numbers, const QString &message, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendInvites(phone_numbers, message);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSendInvites";
        mRecallArgs[msgId]["phone_numbers"] = QVariant::fromValue<QList<QString>>(phone_numbers);
        mRecallArgs[msgId]["message"] = QVariant::fromValue<QString>(message);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendInvitesAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSendInvitesAnswer(msgId, result);
}

void TelegramCore::onAuthSendInvitesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSendInvitesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authExportAuthorization(qint32 dc_id, Callback<AuthExportedAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthExportedAuthorization &result = AuthExportedAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authExportAuthorization(dc_id);
    if(msgId) {
        callBackPush<AuthExportedAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authExportAuthorization";
        mRecallArgs[msgId]["dc_id"] = QVariant::fromValue<qint32>(dc_id);
    } else {
        const AuthExportedAuthorization &result = AuthExportedAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthExportAuthorizationAnswer(qint64 msgId, const AuthExportedAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthExportedAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authExportAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAuthExportAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthExportedAuthorization &result = AuthExportedAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthExportedAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authExportAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authImportAuthorization(qint32 id, const QByteArray &bytes, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authImportAuthorization(id, bytes);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authImportAuthorization";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<qint32>(id);
        mRecallArgs[msgId]["bytes"] = QVariant::fromValue<QByteArray>(bytes);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthImportAuthorizationAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authImportAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAuthImportAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authImportAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authBindTempAuthKey(qint64 perm_auth_key_id, qint64 nonce, qint32 expires_at, const QByteArray &encrypted_message, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authBindTempAuthKey(perm_auth_key_id, nonce, expires_at, encrypted_message);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authBindTempAuthKey";
        mRecallArgs[msgId]["perm_auth_key_id"] = QVariant::fromValue<qint64>(perm_auth_key_id);
        mRecallArgs[msgId]["nonce"] = QVariant::fromValue<qint64>(nonce);
        mRecallArgs[msgId]["expires_at"] = QVariant::fromValue<qint32>(expires_at);
        mRecallArgs[msgId]["encrypted_message"] = QVariant::fromValue<QByteArray>(encrypted_message);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthBindTempAuthKeyAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authBindTempAuthKeyAnswer(msgId, result);
}

void TelegramCore::onAuthBindTempAuthKeyError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authBindTempAuthKeyError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendSms(const QString &phone_number, const QString &phone_code_hash, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendSms(phone_number, phone_code_hash);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSendSms";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendSmsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSendSmsAnswer(msgId, result);
}

void TelegramCore::onAuthSendSmsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSendSmsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authCheckPassword(const QByteArray &password_hash, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authCheckPassword(password_hash);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authCheckPassword";
        mRecallArgs[msgId]["password_hash"] = QVariant::fromValue<QByteArray>(password_hash);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthCheckPasswordAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authCheckPasswordAnswer(msgId, result);
}

void TelegramCore::onAuthCheckPasswordError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authCheckPasswordError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authRequestPasswordRecovery(Callback<AuthPasswordRecovery > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthPasswordRecovery &result = AuthPasswordRecovery();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authRequestPasswordRecovery();
    if(msgId) {
        callBackPush<AuthPasswordRecovery >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authRequestPasswordRecovery";
    } else {
        const AuthPasswordRecovery &result = AuthPasswordRecovery();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthRequestPasswordRecoveryAnswer(qint64 msgId, const AuthPasswordRecovery &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthPasswordRecovery >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authRequestPasswordRecoveryAnswer(msgId, result);
}

void TelegramCore::onAuthRequestPasswordRecoveryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthPasswordRecovery &result = AuthPasswordRecovery();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthPasswordRecovery >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authRequestPasswordRecoveryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authRecoverPassword(const QString &code, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authRecoverPassword(code);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authRecoverPassword";
        mRecallArgs[msgId]["code"] = QVariant::fromValue<QString>(code);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthRecoverPasswordAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authRecoverPasswordAnswer(msgId, result);
}

void TelegramCore::onAuthRecoverPasswordError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authRecoverPasswordError(msgId, errorCode, errorText);
}


qint64 TelegramCore::contactsGetStatuses(Callback<QList<ContactStatus> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<ContactStatus> &result = QList<ContactStatus>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetStatuses();
    if(msgId) {
        callBackPush<QList<ContactStatus> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsGetStatuses";
    } else {
        const QList<ContactStatus> &result = QList<ContactStatus>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetStatusesAnswer(qint64 msgId, const QList<ContactStatus> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<QList<ContactStatus> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsGetStatusesAnswer(msgId, result);
}

void TelegramCore::onContactsGetStatusesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const QList<ContactStatus> &result = QList<ContactStatus>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<ContactStatus> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsGetStatusesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsGetContacts(const QString &hash, Callback<ContactsContacts > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsContacts &result = ContactsContacts();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetContacts(hash);
    if(msgId) {
        callBackPush<ContactsContacts >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsGetContacts";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<QString>(hash);
    } else {
        const ContactsContacts &result = ContactsContacts();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetContactsAnswer(qint64 msgId, const ContactsContacts &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<ContactsContacts >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsGetContactsAnswer(msgId, result);
}

void TelegramCore::onContactsGetContactsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const ContactsContacts &result = ContactsContacts();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsContacts >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsGetContactsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsImportContacts(const QList<InputContact> &contacts, bool replace, Callback<ContactsImportedContacts > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsImportedContacts &result = ContactsImportedContacts();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsImportContacts(contacts, replace);
    if(msgId) {
        callBackPush<ContactsImportedContacts >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsImportContacts";
        mRecallArgs[msgId]["contacts"] = QVariant::fromValue<QList<InputContact>>(contacts);
        mRecallArgs[msgId]["replace"] = QVariant::fromValue<bool>(replace);
    } else {
        const ContactsImportedContacts &result = ContactsImportedContacts();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsImportContactsAnswer(qint64 msgId, const ContactsImportedContacts &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<ContactsImportedContacts >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsImportContactsAnswer(msgId, result);
}

void TelegramCore::onContactsImportContactsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const ContactsImportedContacts &result = ContactsImportedContacts();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsImportedContacts >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsImportContactsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsGetSuggested(qint32 limit, Callback<ContactsSuggested > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsSuggested &result = ContactsSuggested();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetSuggested(limit);
    if(msgId) {
        callBackPush<ContactsSuggested >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsGetSuggested";
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const ContactsSuggested &result = ContactsSuggested();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetSuggestedAnswer(qint64 msgId, const ContactsSuggested &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<ContactsSuggested >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsGetSuggestedAnswer(msgId, result);
}

void TelegramCore::onContactsGetSuggestedError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const ContactsSuggested &result = ContactsSuggested();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsSuggested >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsGetSuggestedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsDeleteContact(const InputUser &id, Callback<ContactsLink > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsLink &result = ContactsLink();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsDeleteContact(id);
    if(msgId) {
        callBackPush<ContactsLink >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsDeleteContact";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputUser>(id);
    } else {
        const ContactsLink &result = ContactsLink();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsDeleteContactAnswer(qint64 msgId, const ContactsLink &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<ContactsLink >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsDeleteContactAnswer(msgId, result);
}

void TelegramCore::onContactsDeleteContactError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const ContactsLink &result = ContactsLink();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsLink >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsDeleteContactError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsDeleteContacts(const QList<InputUser> &id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsDeleteContacts(id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsDeleteContacts";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<InputUser>>(id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsDeleteContactsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsDeleteContactsAnswer(msgId, result);
}

void TelegramCore::onContactsDeleteContactsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsDeleteContactsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsBlock(const InputUser &id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsBlock(id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsBlock";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputUser>(id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsBlockAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsBlockAnswer(msgId, result);
}

void TelegramCore::onContactsBlockError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsBlockError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsUnblock(const InputUser &id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsUnblock(id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsUnblock";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputUser>(id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsUnblockAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsUnblockAnswer(msgId, result);
}

void TelegramCore::onContactsUnblockError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsUnblockError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsGetBlocked(qint32 offset, qint32 limit, Callback<ContactsBlocked > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsBlocked &result = ContactsBlocked();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetBlocked(offset, limit);
    if(msgId) {
        callBackPush<ContactsBlocked >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsGetBlocked";
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const ContactsBlocked &result = ContactsBlocked();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetBlockedAnswer(qint64 msgId, const ContactsBlocked &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<ContactsBlocked >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsGetBlockedAnswer(msgId, result);
}

void TelegramCore::onContactsGetBlockedError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const ContactsBlocked &result = ContactsBlocked();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsBlocked >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsGetBlockedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsExportCard(Callback<QList<qint32> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsExportCard();
    if(msgId) {
        callBackPush<QList<qint32> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsExportCard";
    } else {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsExportCardAnswer(qint64 msgId, const QList<qint32> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<QList<qint32> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsExportCardAnswer(msgId, result);
}

void TelegramCore::onContactsExportCardError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const QList<qint32> &result = QList<qint32>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint32> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsExportCardError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsImportCard(const QList<qint32> &export_card, Callback<User > callBack, qint32 timeout) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsImportCard(export_card);
    if(msgId) {
        callBackPush<User >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsImportCard";
        mRecallArgs[msgId]["export_card"] = QVariant::fromValue<QList<qint32>>(export_card);
    } else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsImportCardAnswer(qint64 msgId, const User &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<User >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsImportCardAnswer(msgId, result);
}

void TelegramCore::onContactsImportCardError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsImportCardError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsSearch(const QString &q, qint32 limit, Callback<ContactsFound > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsFound &result = ContactsFound();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsSearch(q, limit);
    if(msgId) {
        callBackPush<ContactsFound >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsSearch";
        mRecallArgs[msgId]["q"] = QVariant::fromValue<QString>(q);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const ContactsFound &result = ContactsFound();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsSearchAnswer(qint64 msgId, const ContactsFound &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<ContactsFound >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsSearchAnswer(msgId, result);
}

void TelegramCore::onContactsSearchError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const ContactsFound &result = ContactsFound();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsFound >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsSearchError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsResolveUsername(const QString &username, Callback<User > callBack, qint32 timeout) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsResolveUsername(username);
    if(msgId) {
        callBackPush<User >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsResolveUsername";
        mRecallArgs[msgId]["username"] = QVariant::fromValue<QString>(username);
    } else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsResolveUsernameAnswer(qint64 msgId, const User &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<User >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsResolveUsernameAnswer(msgId, result);
}

void TelegramCore::onContactsResolveUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsResolveUsernameError(msgId, errorCode, errorText);
}


qint64 TelegramCore::geochatsGetLocated(const InputGeoPoint &geo_point, qint32 radius, qint32 limit, Callback<GeochatsLocated > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsLocated &result = GeochatsLocated();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsGetLocated(geo_point, radius, limit);
    if(msgId) {
        callBackPush<GeochatsLocated >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsGetLocated";
        mRecallArgs[msgId]["geo_point"] = QVariant::fromValue<InputGeoPoint>(geo_point);
        mRecallArgs[msgId]["radius"] = QVariant::fromValue<qint32>(radius);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const GeochatsLocated &result = GeochatsLocated();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsGetLocatedAnswer(qint64 msgId, const GeochatsLocated &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsLocated >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsGetLocatedAnswer(msgId, result);
}

void TelegramCore::onGeochatsGetLocatedError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsLocated &result = GeochatsLocated();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsLocated >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsGetLocatedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsGetRecents(qint32 offset, qint32 limit, Callback<GeochatsMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsMessages &result = GeochatsMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsGetRecents(offset, limit);
    if(msgId) {
        callBackPush<GeochatsMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsGetRecents";
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const GeochatsMessages &result = GeochatsMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsGetRecentsAnswer(qint64 msgId, const GeochatsMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsGetRecentsAnswer(msgId, result);
}

void TelegramCore::onGeochatsGetRecentsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsMessages &result = GeochatsMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsGetRecentsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsCheckin(const InputGeoChat &peer, Callback<GeochatsStatedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsCheckin(peer);
    if(msgId) {
        callBackPush<GeochatsStatedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsCheckin";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputGeoChat>(peer);
    } else {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsCheckinAnswer(qint64 msgId, const GeochatsStatedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsStatedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsCheckinAnswer(msgId, result);
}

void TelegramCore::onGeochatsCheckinError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsStatedMessage &result = GeochatsStatedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsStatedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsCheckinError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsGetFullChat(const InputGeoChat &peer, Callback<MessagesChatFull > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsGetFullChat(peer);
    if(msgId) {
        callBackPush<MessagesChatFull >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsGetFullChat";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputGeoChat>(peer);
    } else {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsGetFullChatAnswer(qint64 msgId, const MessagesChatFull &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesChatFull >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsGetFullChatAnswer(msgId, result);
}

void TelegramCore::onGeochatsGetFullChatError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesChatFull &result = MessagesChatFull();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChatFull >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsGetFullChatError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsEditChatTitle(const InputGeoChat &peer, const QString &title, const QString &address, Callback<GeochatsStatedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsEditChatTitle(peer, title, address);
    if(msgId) {
        callBackPush<GeochatsStatedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsEditChatTitle";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputGeoChat>(peer);
        mRecallArgs[msgId]["title"] = QVariant::fromValue<QString>(title);
        mRecallArgs[msgId]["address"] = QVariant::fromValue<QString>(address);
    } else {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsEditChatTitleAnswer(qint64 msgId, const GeochatsStatedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsStatedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsEditChatTitleAnswer(msgId, result);
}

void TelegramCore::onGeochatsEditChatTitleError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsStatedMessage &result = GeochatsStatedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsStatedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsEditChatTitleError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsEditChatPhoto(const InputGeoChat &peer, const InputChatPhoto &photo, Callback<GeochatsStatedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsEditChatPhoto(peer, photo);
    if(msgId) {
        callBackPush<GeochatsStatedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsEditChatPhoto";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputGeoChat>(peer);
        mRecallArgs[msgId]["photo"] = QVariant::fromValue<InputChatPhoto>(photo);
    } else {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsEditChatPhotoAnswer(qint64 msgId, const GeochatsStatedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsStatedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsEditChatPhotoAnswer(msgId, result);
}

void TelegramCore::onGeochatsEditChatPhotoError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsStatedMessage &result = GeochatsStatedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsStatedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsEditChatPhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsSearch(const InputGeoChat &peer, const QString &q, const MessagesFilter &filter, qint32 min_date, qint32 max_date, qint32 offset, qint32 max_id, qint32 limit, Callback<GeochatsMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsMessages &result = GeochatsMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsSearch(peer, q, filter, min_date, max_date, offset, max_id, limit);
    if(msgId) {
        callBackPush<GeochatsMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsSearch";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputGeoChat>(peer);
        mRecallArgs[msgId]["q"] = QVariant::fromValue<QString>(q);
        mRecallArgs[msgId]["filter"] = QVariant::fromValue<MessagesFilter>(filter);
        mRecallArgs[msgId]["min_date"] = QVariant::fromValue<qint32>(min_date);
        mRecallArgs[msgId]["max_date"] = QVariant::fromValue<qint32>(max_date);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const GeochatsMessages &result = GeochatsMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsSearchAnswer(qint64 msgId, const GeochatsMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsSearchAnswer(msgId, result);
}

void TelegramCore::onGeochatsSearchError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsMessages &result = GeochatsMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsSearchError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsGetHistory(const InputGeoChat &peer, qint32 offset, qint32 max_id, qint32 limit, Callback<GeochatsMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsMessages &result = GeochatsMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsGetHistory(peer, offset, max_id, limit);
    if(msgId) {
        callBackPush<GeochatsMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsGetHistory";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputGeoChat>(peer);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const GeochatsMessages &result = GeochatsMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsGetHistoryAnswer(qint64 msgId, const GeochatsMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsGetHistoryAnswer(msgId, result);
}

void TelegramCore::onGeochatsGetHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsMessages &result = GeochatsMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsGetHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsSetTyping(const InputGeoChat &peer, bool typing, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsSetTyping(peer, typing);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsSetTyping";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputGeoChat>(peer);
        mRecallArgs[msgId]["typing"] = QVariant::fromValue<bool>(typing);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsSetTypingAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsSetTypingAnswer(msgId, result);
}

void TelegramCore::onGeochatsSetTypingError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsSetTypingError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsSendMessage(const InputGeoChat &peer, const QString &message, qint64 random_id, Callback<GeochatsStatedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsSendMessage(peer, message, random_id);
    if(msgId) {
        callBackPush<GeochatsStatedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsSendMessage";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputGeoChat>(peer);
        mRecallArgs[msgId]["message"] = QVariant::fromValue<QString>(message);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
    } else {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsSendMessageAnswer(qint64 msgId, const GeochatsStatedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsStatedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsSendMessageAnswer(msgId, result);
}

void TelegramCore::onGeochatsSendMessageError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsStatedMessage &result = GeochatsStatedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsStatedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsSendMessageError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsSendMedia(const InputGeoChat &peer, const InputMedia &media, qint64 random_id, Callback<GeochatsStatedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsSendMedia(peer, media, random_id);
    if(msgId) {
        callBackPush<GeochatsStatedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsSendMedia";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputGeoChat>(peer);
        mRecallArgs[msgId]["media"] = QVariant::fromValue<InputMedia>(media);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
    } else {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsSendMediaAnswer(qint64 msgId, const GeochatsStatedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsStatedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsSendMediaAnswer(msgId, result);
}

void TelegramCore::onGeochatsSendMediaError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsStatedMessage &result = GeochatsStatedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsStatedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsSendMediaError(msgId, errorCode, errorText);
}

qint64 TelegramCore::geochatsCreateGeoChat(const QString &title, const InputGeoPoint &geo_point, const QString &address, const QString &venue, Callback<GeochatsStatedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->geochatsCreateGeoChat(title, geo_point, address, venue);
    if(msgId) {
        callBackPush<GeochatsStatedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "geochatsCreateGeoChat";
        mRecallArgs[msgId]["title"] = QVariant::fromValue<QString>(title);
        mRecallArgs[msgId]["geo_point"] = QVariant::fromValue<InputGeoPoint>(geo_point);
        mRecallArgs[msgId]["address"] = QVariant::fromValue<QString>(address);
        mRecallArgs[msgId]["venue"] = QVariant::fromValue<QString>(venue);
    } else {
        const GeochatsStatedMessage &result = GeochatsStatedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onGeochatsCreateGeoChatAnswer(qint64 msgId, const GeochatsStatedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<GeochatsStatedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT geochatsCreateGeoChatAnswer(msgId, result);
}

void TelegramCore::onGeochatsCreateGeoChatError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const GeochatsStatedMessage &result = GeochatsStatedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<GeochatsStatedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT geochatsCreateGeoChatError(msgId, errorCode, errorText);
}


qint64 TelegramCore::helpGetConfig(Callback<Config > callBack, qint32 timeout) {
    if(!mApi) {
        const Config &result = Config();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetConfig();
    if(msgId) {
        callBackPush<Config >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetConfig";
    } else {
        const Config &result = Config();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetConfigAnswer(qint64 msgId, const Config &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<Config >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetConfigAnswer(msgId, result);
}

void TelegramCore::onHelpGetConfigError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const Config &result = Config();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<Config >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetConfigError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetNearestDc(Callback<NearestDc > callBack, qint32 timeout) {
    if(!mApi) {
        const NearestDc &result = NearestDc();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetNearestDc();
    if(msgId) {
        callBackPush<NearestDc >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetNearestDc";
    } else {
        const NearestDc &result = NearestDc();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetNearestDcAnswer(qint64 msgId, const NearestDc &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<NearestDc >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetNearestDcAnswer(msgId, result);
}

void TelegramCore::onHelpGetNearestDcError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const NearestDc &result = NearestDc();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<NearestDc >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetNearestDcError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetAppUpdate(const QString &device_model, const QString &system_version, const QString &app_version, const QString &lang_code, Callback<HelpAppUpdate > callBack, qint32 timeout) {
    if(!mApi) {
        const HelpAppUpdate &result = HelpAppUpdate();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetAppUpdate(device_model, system_version, app_version, lang_code);
    if(msgId) {
        callBackPush<HelpAppUpdate >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetAppUpdate";
        mRecallArgs[msgId]["device_model"] = QVariant::fromValue<QString>(device_model);
        mRecallArgs[msgId]["system_version"] = QVariant::fromValue<QString>(system_version);
        mRecallArgs[msgId]["app_version"] = QVariant::fromValue<QString>(app_version);
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        const HelpAppUpdate &result = HelpAppUpdate();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetAppUpdateAnswer(qint64 msgId, const HelpAppUpdate &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<HelpAppUpdate >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetAppUpdateAnswer(msgId, result);
}

void TelegramCore::onHelpGetAppUpdateError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const HelpAppUpdate &result = HelpAppUpdate();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpAppUpdate >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetAppUpdateError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpSaveAppLog(const QList<InputAppEvent> &events, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpSaveAppLog(events);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpSaveAppLog";
        mRecallArgs[msgId]["events"] = QVariant::fromValue<QList<InputAppEvent>>(events);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpSaveAppLogAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpSaveAppLogAnswer(msgId, result);
}

void TelegramCore::onHelpSaveAppLogError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpSaveAppLogError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetInviteText(const QString &lang_code, Callback<HelpInviteText > callBack, qint32 timeout) {
    if(!mApi) {
        const HelpInviteText &result = HelpInviteText();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetInviteText(lang_code);
    if(msgId) {
        callBackPush<HelpInviteText >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetInviteText";
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        const HelpInviteText &result = HelpInviteText();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetInviteTextAnswer(qint64 msgId, const HelpInviteText &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<HelpInviteText >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetInviteTextAnswer(msgId, result);
}

void TelegramCore::onHelpGetInviteTextError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const HelpInviteText &result = HelpInviteText();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpInviteText >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetInviteTextError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetSupport(Callback<HelpSupport > callBack, qint32 timeout) {
    if(!mApi) {
        const HelpSupport &result = HelpSupport();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetSupport();
    if(msgId) {
        callBackPush<HelpSupport >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetSupport";
    } else {
        const HelpSupport &result = HelpSupport();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetSupportAnswer(qint64 msgId, const HelpSupport &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<HelpSupport >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetSupportAnswer(msgId, result);
}

void TelegramCore::onHelpGetSupportError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const HelpSupport &result = HelpSupport();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpSupport >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetSupportError(msgId, errorCode, errorText);
}


qint64 TelegramCore::messagesStartBot(const InputUser &bot, qint32 chat_id, qint64 random_id, const QString &start_param, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesStartBot(bot, chat_id, random_id, start_param);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesStartBot";
        mRecallArgs[msgId]["bot"] = QVariant::fromValue<InputUser>(bot);
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["start_param"] = QVariant::fromValue<QString>(start_param);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesStartBotAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesStartBotAnswer(msgId, result);
}

void TelegramCore::onMessagesStartBotError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesStartBotError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetMessages(const QList<qint32> &id, Callback<MessagesMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetMessages(id);
    if(msgId) {
        callBackPush<MessagesMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetMessages";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetMessagesAnswer(qint64 msgId, const MessagesMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesGetMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetDialogs(qint32 offset, qint32 max_id, qint32 limit, Callback<MessagesDialogs > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetDialogs(offset, max_id, limit);
    if(msgId) {
        callBackPush<MessagesDialogs >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetDialogs";
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetDialogsAnswer(qint64 msgId, const MessagesDialogs &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesDialogs >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDialogsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetDialogsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesDialogs &result = MessagesDialogs();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesDialogs >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDialogsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetHistory(const InputPeer &peer, qint32 offset, qint32 max_id, qint32 limit, Callback<MessagesMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetHistory(peer, offset, max_id, limit);
    if(msgId) {
        callBackPush<MessagesMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetHistory";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetHistoryAnswer(qint64 msgId, const MessagesMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesGetHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSearch(const InputPeer &peer, const QString &q, const MessagesFilter &filter, qint32 min_date, qint32 max_date, qint32 offset, qint32 max_id, qint32 limit, Callback<MessagesMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSearch(peer, q, filter, min_date, max_date, offset, max_id, limit);
    if(msgId) {
        callBackPush<MessagesMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSearch";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["q"] = QVariant::fromValue<QString>(q);
        mRecallArgs[msgId]["filter"] = QVariant::fromValue<MessagesFilter>(filter);
        mRecallArgs[msgId]["min_date"] = QVariant::fromValue<qint32>(min_date);
        mRecallArgs[msgId]["max_date"] = QVariant::fromValue<qint32>(max_date);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSearchAnswer(qint64 msgId, const MessagesMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSearchAnswer(msgId, result);
}

void TelegramCore::onMessagesSearchError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSearchError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReadHistory(const InputPeer &peer, qint32 max_id, qint32 offset, Callback<MessagesAffectedHistory > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReadHistory(peer, max_id, offset);
    if(msgId) {
        callBackPush<MessagesAffectedHistory >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReadHistory";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
    } else {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReadHistoryAnswer(qint64 msgId, const MessagesAffectedHistory &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesAffectedHistory >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReadHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesReadHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesAffectedHistory &result = MessagesAffectedHistory();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedHistory >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReadHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDeleteHistory(const InputPeer &peer, qint32 offset, Callback<MessagesAffectedHistory > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDeleteHistory(peer, offset);
    if(msgId) {
        callBackPush<MessagesAffectedHistory >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesDeleteHistory";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
    } else {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDeleteHistoryAnswer(qint64 msgId, const MessagesAffectedHistory &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesAffectedHistory >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesDeleteHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesAffectedHistory &result = MessagesAffectedHistory();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedHistory >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDeleteMessages(const QList<qint32> &id, Callback<MessagesAffectedMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDeleteMessages(id);
    if(msgId) {
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesDeleteMessages";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDeleteMessagesAnswer(qint64 msgId, const MessagesAffectedMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesAffectedMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesDeleteMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReceivedMessages(qint32 max_id, Callback<QList<ReceivedNotifyMessage> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<ReceivedNotifyMessage> &result = QList<ReceivedNotifyMessage>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReceivedMessages(max_id);
    if(msgId) {
        callBackPush<QList<ReceivedNotifyMessage> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReceivedMessages";
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
    } else {
        const QList<ReceivedNotifyMessage> &result = QList<ReceivedNotifyMessage>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReceivedMessagesAnswer(qint64 msgId, const QList<ReceivedNotifyMessage> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<QList<ReceivedNotifyMessage> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReceivedMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesReceivedMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const QList<ReceivedNotifyMessage> &result = QList<ReceivedNotifyMessage>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<ReceivedNotifyMessage> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReceivedMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSetTyping(const InputPeer &peer, const SendMessageAction &action, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSetTyping(peer, action);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSetTyping";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["action"] = QVariant::fromValue<SendMessageAction>(action);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSetTypingAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSetTypingAnswer(msgId, result);
}

void TelegramCore::onMessagesSetTypingError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSetTypingError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendMessage(const InputPeer &peer, qint32 reply_to_msg_id, const QString &message, qint64 random_id, const ReplyMarkup &reply_markup, Callback<MessagesSentMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesSentMessage &result = MessagesSentMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendMessage(peer, reply_to_msg_id, message, random_id, reply_markup);
    if(msgId) {
        callBackPush<MessagesSentMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendMessage";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["reply_to_msg_id"] = QVariant::fromValue<qint32>(reply_to_msg_id);
        mRecallArgs[msgId]["message"] = QVariant::fromValue<QString>(message);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["reply_markup"] = QVariant::fromValue<ReplyMarkup>(reply_markup);
    } else {
        const MessagesSentMessage &result = MessagesSentMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendMessageAnswer(qint64 msgId, const MessagesSentMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesSentMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendMessageAnswer(msgId, result);
}

void TelegramCore::onMessagesSendMessageError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesSentMessage &result = MessagesSentMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendMessageError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendMedia(const InputPeer &peer, qint32 reply_to_msg_id, const InputMedia &media, qint64 random_id, const ReplyMarkup &reply_markup, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendMedia(peer, reply_to_msg_id, media, random_id, reply_markup);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendMedia";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["reply_to_msg_id"] = QVariant::fromValue<qint32>(reply_to_msg_id);
        mRecallArgs[msgId]["media"] = QVariant::fromValue<InputMedia>(media);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["reply_markup"] = QVariant::fromValue<ReplyMarkup>(reply_markup);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendMediaAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendMediaAnswer(msgId, result);
}

void TelegramCore::onMessagesSendMediaError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendMediaError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesForwardMessages(const InputPeer &peer, const QList<qint32> &id, const QList<qint64> &random_id, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesForwardMessages(peer, id, random_id);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesForwardMessages";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<QList<qint64>>(random_id);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesForwardMessagesAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesForwardMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesForwardMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesForwardMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetChats(const QList<qint32> &id, Callback<MessagesChats > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetChats(id);
    if(msgId) {
        callBackPush<MessagesChats >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetChats";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetChatsAnswer(qint64 msgId, const MessagesChats &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesChats >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetChatsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetChatsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesChats &result = MessagesChats();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChats >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetChatsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetFullChat(qint32 chat_id, Callback<MessagesChatFull > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetFullChat(chat_id);
    if(msgId) {
        callBackPush<MessagesChatFull >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetFullChat";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
    } else {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetFullChatAnswer(qint64 msgId, const MessagesChatFull &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesChatFull >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetFullChatAnswer(msgId, result);
}

void TelegramCore::onMessagesGetFullChatError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesChatFull &result = MessagesChatFull();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChatFull >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetFullChatError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesEditChatTitle(qint32 chat_id, const QString &title, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesEditChatTitle(chat_id, title);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesEditChatTitle";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["title"] = QVariant::fromValue<QString>(title);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesEditChatTitleAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatTitleAnswer(msgId, result);
}

void TelegramCore::onMessagesEditChatTitleError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatTitleError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesEditChatPhoto(qint32 chat_id, const InputChatPhoto &photo, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesEditChatPhoto(chat_id, photo);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesEditChatPhoto";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["photo"] = QVariant::fromValue<InputChatPhoto>(photo);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesEditChatPhotoAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatPhotoAnswer(msgId, result);
}

void TelegramCore::onMessagesEditChatPhotoError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatPhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesAddChatUser(qint32 chat_id, const InputUser &user_id, qint32 fwd_limit, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesAddChatUser(chat_id, user_id, fwd_limit);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesAddChatUser";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["fwd_limit"] = QVariant::fromValue<qint32>(fwd_limit);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesAddChatUserAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesAddChatUserAnswer(msgId, result);
}

void TelegramCore::onMessagesAddChatUserError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesAddChatUserError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDeleteChatUser(qint32 chat_id, const InputUser &user_id, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDeleteChatUser(chat_id, user_id);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesDeleteChatUser";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDeleteChatUserAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteChatUserAnswer(msgId, result);
}

void TelegramCore::onMessagesDeleteChatUserError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteChatUserError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesCreateChat(const QList<InputUser> &users, const QString &title, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesCreateChat(users, title);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesCreateChat";
        mRecallArgs[msgId]["users"] = QVariant::fromValue<QList<InputUser>>(users);
        mRecallArgs[msgId]["title"] = QVariant::fromValue<QString>(title);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesCreateChatAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesCreateChatAnswer(msgId, result);
}

void TelegramCore::onMessagesCreateChatError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesCreateChatError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesForwardMessage(const InputPeer &peer, qint32 id, qint64 random_id, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesForwardMessage(peer, id, random_id);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesForwardMessage";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["id"] = QVariant::fromValue<qint32>(id);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesForwardMessageAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesForwardMessageAnswer(msgId, result);
}

void TelegramCore::onMessagesForwardMessageError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesForwardMessageError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendBroadcast(const QList<InputUser> &contacts, const QList<qint64> &random_id, const QString &message, const InputMedia &media, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendBroadcast(contacts, random_id, message, media);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendBroadcast";
        mRecallArgs[msgId]["contacts"] = QVariant::fromValue<QList<InputUser>>(contacts);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<QList<qint64>>(random_id);
        mRecallArgs[msgId]["message"] = QVariant::fromValue<QString>(message);
        mRecallArgs[msgId]["media"] = QVariant::fromValue<InputMedia>(media);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendBroadcastAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendBroadcastAnswer(msgId, result);
}

void TelegramCore::onMessagesSendBroadcastError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendBroadcastError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetDhConfig(qint32 version, qint32 random_length, Callback<MessagesDhConfig > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesDhConfig &result = MessagesDhConfig();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetDhConfig(version, random_length);
    if(msgId) {
        callBackPush<MessagesDhConfig >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetDhConfig";
        mRecallArgs[msgId]["version"] = QVariant::fromValue<qint32>(version);
        mRecallArgs[msgId]["random_length"] = QVariant::fromValue<qint32>(random_length);
    } else {
        const MessagesDhConfig &result = MessagesDhConfig();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetDhConfigAnswer(qint64 msgId, const MessagesDhConfig &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesDhConfig >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDhConfigAnswer(msgId, result);
}

void TelegramCore::onMessagesGetDhConfigError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesDhConfig &result = MessagesDhConfig();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesDhConfig >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDhConfigError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesRequestEncryption(const InputUser &user_id, qint32 random_id, const QByteArray &g_a, Callback<EncryptedChat > callBack, qint32 timeout) {
    if(!mApi) {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesRequestEncryption(user_id, random_id, g_a);
    if(msgId) {
        callBackPush<EncryptedChat >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesRequestEncryption";
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint32>(random_id);
        mRecallArgs[msgId]["g_a"] = QVariant::fromValue<QByteArray>(g_a);
    } else {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesRequestEncryptionAnswer(qint64 msgId, const EncryptedChat &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<EncryptedChat >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesRequestEncryptionAnswer(msgId, result);
}

void TelegramCore::onMessagesRequestEncryptionError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const EncryptedChat &result = EncryptedChat();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<EncryptedChat >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesRequestEncryptionError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesAcceptEncryption(const InputEncryptedChat &peer, const QByteArray &g_b, qint64 key_fingerprint, Callback<EncryptedChat > callBack, qint32 timeout) {
    if(!mApi) {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesAcceptEncryption(peer, g_b, key_fingerprint);
    if(msgId) {
        callBackPush<EncryptedChat >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesAcceptEncryption";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["g_b"] = QVariant::fromValue<QByteArray>(g_b);
        mRecallArgs[msgId]["key_fingerprint"] = QVariant::fromValue<qint64>(key_fingerprint);
    } else {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesAcceptEncryptionAnswer(qint64 msgId, const EncryptedChat &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<EncryptedChat >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesAcceptEncryptionAnswer(msgId, result);
}

void TelegramCore::onMessagesAcceptEncryptionError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const EncryptedChat &result = EncryptedChat();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<EncryptedChat >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesAcceptEncryptionError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDiscardEncryption(qint32 chat_id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDiscardEncryption(chat_id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesDiscardEncryption";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDiscardEncryptionAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesDiscardEncryptionAnswer(msgId, result);
}

void TelegramCore::onMessagesDiscardEncryptionError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesDiscardEncryptionError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSetEncryptedTyping(const InputEncryptedChat &peer, bool typing, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSetEncryptedTyping(peer, typing);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSetEncryptedTyping";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["typing"] = QVariant::fromValue<bool>(typing);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSetEncryptedTypingAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSetEncryptedTypingAnswer(msgId, result);
}

void TelegramCore::onMessagesSetEncryptedTypingError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSetEncryptedTypingError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReadEncryptedHistory(const InputEncryptedChat &peer, qint32 max_date, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReadEncryptedHistory(peer, max_date);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReadEncryptedHistory";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["max_date"] = QVariant::fromValue<qint32>(max_date);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReadEncryptedHistoryAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReadEncryptedHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesReadEncryptedHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReadEncryptedHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendEncrypted(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, Callback<MessagesSentEncryptedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendEncrypted(peer, random_id, data);
    if(msgId) {
        callBackPush<MessagesSentEncryptedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendEncrypted";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["data"] = QVariant::fromValue<QByteArray>(data);
    } else {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendEncryptedAnswer(qint64 msgId, const MessagesSentEncryptedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesSentEncryptedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedAnswer(msgId, result);
}

void TelegramCore::onMessagesSendEncryptedError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentEncryptedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendEncryptedFile(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, const InputEncryptedFile &file, Callback<MessagesSentEncryptedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendEncryptedFile(peer, random_id, data, file);
    if(msgId) {
        callBackPush<MessagesSentEncryptedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendEncryptedFile";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["data"] = QVariant::fromValue<QByteArray>(data);
        mRecallArgs[msgId]["file"] = QVariant::fromValue<InputEncryptedFile>(file);
    } else {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendEncryptedFileAnswer(qint64 msgId, const MessagesSentEncryptedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesSentEncryptedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedFileAnswer(msgId, result);
}

void TelegramCore::onMessagesSendEncryptedFileError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentEncryptedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedFileError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendEncryptedService(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, Callback<MessagesSentEncryptedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendEncryptedService(peer, random_id, data);
    if(msgId) {
        callBackPush<MessagesSentEncryptedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendEncryptedService";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["data"] = QVariant::fromValue<QByteArray>(data);
    } else {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendEncryptedServiceAnswer(qint64 msgId, const MessagesSentEncryptedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesSentEncryptedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedServiceAnswer(msgId, result);
}

void TelegramCore::onMessagesSendEncryptedServiceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentEncryptedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedServiceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReceivedQueue(qint32 max_qts, Callback<QList<qint64> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReceivedQueue(max_qts);
    if(msgId) {
        callBackPush<QList<qint64> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReceivedQueue";
        mRecallArgs[msgId]["max_qts"] = QVariant::fromValue<qint32>(max_qts);
    } else {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReceivedQueueAnswer(qint64 msgId, const QList<qint64> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<QList<qint64> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReceivedQueueAnswer(msgId, result);
}

void TelegramCore::onMessagesReceivedQueueError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const QList<qint64> &result = QList<qint64>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint64> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReceivedQueueError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReadMessageContents(const QList<qint32> &id, Callback<MessagesAffectedMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReadMessageContents(id);
    if(msgId) {
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReadMessageContents";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReadMessageContentsAnswer(qint64 msgId, const MessagesAffectedMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesAffectedMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReadMessageContentsAnswer(msgId, result);
}

void TelegramCore::onMessagesReadMessageContentsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReadMessageContentsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetStickers(const QString &emoticon, const QString &hash, Callback<MessagesStickers > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesStickers &result = MessagesStickers();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetStickers(emoticon, hash);
    if(msgId) {
        callBackPush<MessagesStickers >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetStickers";
        mRecallArgs[msgId]["emoticon"] = QVariant::fromValue<QString>(emoticon);
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<QString>(hash);
    } else {
        const MessagesStickers &result = MessagesStickers();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetStickersAnswer(qint64 msgId, const MessagesStickers &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesStickers >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetStickersAnswer(msgId, result);
}

void TelegramCore::onMessagesGetStickersError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesStickers &result = MessagesStickers();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesStickers >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetStickersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetAllStickers(const QString &hash, Callback<MessagesAllStickers > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAllStickers &result = MessagesAllStickers();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetAllStickers(hash);
    if(msgId) {
        callBackPush<MessagesAllStickers >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetAllStickers";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<QString>(hash);
    } else {
        const MessagesAllStickers &result = MessagesAllStickers();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetAllStickersAnswer(qint64 msgId, const MessagesAllStickers &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesAllStickers >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetAllStickersAnswer(msgId, result);
}

void TelegramCore::onMessagesGetAllStickersError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesAllStickers &result = MessagesAllStickers();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAllStickers >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetAllStickersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetWebPagePreview(const QString &message, Callback<MessageMedia > callBack, qint32 timeout) {
    if(!mApi) {
        const MessageMedia &result = MessageMedia();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetWebPagePreview(message);
    if(msgId) {
        callBackPush<MessageMedia >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetWebPagePreview";
        mRecallArgs[msgId]["message"] = QVariant::fromValue<QString>(message);
    } else {
        const MessageMedia &result = MessageMedia();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetWebPagePreviewAnswer(qint64 msgId, const MessageMedia &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessageMedia >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetWebPagePreviewAnswer(msgId, result);
}

void TelegramCore::onMessagesGetWebPagePreviewError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessageMedia &result = MessageMedia();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessageMedia >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetWebPagePreviewError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesExportChatInvite(qint32 chat_id, Callback<ExportedChatInvite > callBack, qint32 timeout) {
    if(!mApi) {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesExportChatInvite(chat_id);
    if(msgId) {
        callBackPush<ExportedChatInvite >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesExportChatInvite";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
    } else {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesExportChatInviteAnswer(qint64 msgId, const ExportedChatInvite &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<ExportedChatInvite >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesExportChatInviteAnswer(msgId, result);
}

void TelegramCore::onMessagesExportChatInviteError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const ExportedChatInvite &result = ExportedChatInvite();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ExportedChatInvite >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesExportChatInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesCheckChatInvite(const QString &hash, Callback<ChatInvite > callBack, qint32 timeout) {
    if(!mApi) {
        const ChatInvite &result = ChatInvite();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesCheckChatInvite(hash);
    if(msgId) {
        callBackPush<ChatInvite >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesCheckChatInvite";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<QString>(hash);
    } else {
        const ChatInvite &result = ChatInvite();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesCheckChatInviteAnswer(qint64 msgId, const ChatInvite &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<ChatInvite >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesCheckChatInviteAnswer(msgId, result);
}

void TelegramCore::onMessagesCheckChatInviteError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const ChatInvite &result = ChatInvite();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ChatInvite >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesCheckChatInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesImportChatInvite(const QString &hash, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesImportChatInvite(hash);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesImportChatInvite";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<QString>(hash);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesImportChatInviteAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesImportChatInviteAnswer(msgId, result);
}

void TelegramCore::onMessagesImportChatInviteError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesImportChatInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetStickerSet(const InputStickerSet &stickerset, Callback<MessagesStickerSet > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesStickerSet &result = MessagesStickerSet();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetStickerSet(stickerset);
    if(msgId) {
        callBackPush<MessagesStickerSet >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetStickerSet";
        mRecallArgs[msgId]["stickerset"] = QVariant::fromValue<InputStickerSet>(stickerset);
    } else {
        const MessagesStickerSet &result = MessagesStickerSet();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetStickerSetAnswer(qint64 msgId, const MessagesStickerSet &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<MessagesStickerSet >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetStickerSetAnswer(msgId, result);
}

void TelegramCore::onMessagesGetStickerSetError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const MessagesStickerSet &result = MessagesStickerSet();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesStickerSet >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetStickerSetError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesInstallStickerSet(const InputStickerSet &stickerset, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesInstallStickerSet(stickerset);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesInstallStickerSet";
        mRecallArgs[msgId]["stickerset"] = QVariant::fromValue<InputStickerSet>(stickerset);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesInstallStickerSetAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesInstallStickerSetAnswer(msgId, result);
}

void TelegramCore::onMessagesInstallStickerSetError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesInstallStickerSetError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesUninstallStickerSet(const InputStickerSet &stickerset, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesUninstallStickerSet(stickerset);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesUninstallStickerSet";
        mRecallArgs[msgId]["stickerset"] = QVariant::fromValue<InputStickerSet>(stickerset);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesUninstallStickerSetAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesUninstallStickerSetAnswer(msgId, result);
}

void TelegramCore::onMessagesUninstallStickerSetError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesUninstallStickerSetError(msgId, errorCode, errorText);
}


qint64 TelegramCore::photosUpdateProfilePhoto(const InputPhoto &id, const InputPhotoCrop &crop, Callback<UserProfilePhoto > callBack, qint32 timeout) {
    if(!mApi) {
        const UserProfilePhoto &result = UserProfilePhoto();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosUpdateProfilePhoto(id, crop);
    if(msgId) {
        callBackPush<UserProfilePhoto >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "photosUpdateProfilePhoto";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputPhoto>(id);
        mRecallArgs[msgId]["crop"] = QVariant::fromValue<InputPhotoCrop>(crop);
    } else {
        const UserProfilePhoto &result = UserProfilePhoto();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosUpdateProfilePhotoAnswer(qint64 msgId, const UserProfilePhoto &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UserProfilePhoto >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT photosUpdateProfilePhotoAnswer(msgId, result);
}

void TelegramCore::onPhotosUpdateProfilePhotoError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UserProfilePhoto &result = UserProfilePhoto();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UserProfilePhoto >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT photosUpdateProfilePhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::photosUploadProfilePhoto(const InputFile &file, const QString &caption, const InputGeoPoint &geo_point, const InputPhotoCrop &crop, Callback<PhotosPhoto > callBack, qint32 timeout) {
    if(!mApi) {
        const PhotosPhoto &result = PhotosPhoto();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosUploadProfilePhoto(file, caption, geo_point, crop);
    if(msgId) {
        callBackPush<PhotosPhoto >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "photosUploadProfilePhoto";
        mRecallArgs[msgId]["file"] = QVariant::fromValue<InputFile>(file);
        mRecallArgs[msgId]["caption"] = QVariant::fromValue<QString>(caption);
        mRecallArgs[msgId]["geo_point"] = QVariant::fromValue<InputGeoPoint>(geo_point);
        mRecallArgs[msgId]["crop"] = QVariant::fromValue<InputPhotoCrop>(crop);
    } else {
        const PhotosPhoto &result = PhotosPhoto();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosUploadProfilePhotoAnswer(qint64 msgId, const PhotosPhoto &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<PhotosPhoto >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT photosUploadProfilePhotoAnswer(msgId, result);
}

void TelegramCore::onPhotosUploadProfilePhotoError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const PhotosPhoto &result = PhotosPhoto();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<PhotosPhoto >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT photosUploadProfilePhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::photosDeletePhotos(const QList<InputPhoto> &id, Callback<QList<qint64> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosDeletePhotos(id);
    if(msgId) {
        callBackPush<QList<qint64> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "photosDeletePhotos";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<InputPhoto>>(id);
    } else {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosDeletePhotosAnswer(qint64 msgId, const QList<qint64> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<QList<qint64> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT photosDeletePhotosAnswer(msgId, result);
}

void TelegramCore::onPhotosDeletePhotosError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const QList<qint64> &result = QList<qint64>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint64> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT photosDeletePhotosError(msgId, errorCode, errorText);
}

qint64 TelegramCore::photosGetUserPhotos(const InputUser &user_id, qint32 offset, qint32 max_id, qint32 limit, Callback<PhotosPhotos > callBack, qint32 timeout) {
    if(!mApi) {
        const PhotosPhotos &result = PhotosPhotos();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosGetUserPhotos(user_id, offset, max_id, limit);
    if(msgId) {
        callBackPush<PhotosPhotos >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "photosGetUserPhotos";
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const PhotosPhotos &result = PhotosPhotos();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosGetUserPhotosAnswer(qint64 msgId, const PhotosPhotos &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<PhotosPhotos >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT photosGetUserPhotosAnswer(msgId, result);
}

void TelegramCore::onPhotosGetUserPhotosError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const PhotosPhotos &result = PhotosPhotos();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<PhotosPhotos >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT photosGetUserPhotosError(msgId, errorCode, errorText);
}


qint64 TelegramCore::updatesGetState(Callback<UpdatesState > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesState &result = UpdatesState();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->updatesGetState();
    if(msgId) {
        callBackPush<UpdatesState >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "updatesGetState";
    } else {
        const UpdatesState &result = UpdatesState();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUpdatesGetStateAnswer(qint64 msgId, const UpdatesState &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesState >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT updatesGetStateAnswer(msgId, result);
}

void TelegramCore::onUpdatesGetStateError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesState &result = UpdatesState();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesState >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT updatesGetStateError(msgId, errorCode, errorText);
}

qint64 TelegramCore::updatesGetDifference(qint32 pts, qint32 date, qint32 qts, Callback<UpdatesDifference > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesDifference &result = UpdatesDifference();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->updatesGetDifference(pts, date, qts);
    if(msgId) {
        callBackPush<UpdatesDifference >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "updatesGetDifference";
        mRecallArgs[msgId]["pts"] = QVariant::fromValue<qint32>(pts);
        mRecallArgs[msgId]["date"] = QVariant::fromValue<qint32>(date);
        mRecallArgs[msgId]["qts"] = QVariant::fromValue<qint32>(qts);
    } else {
        const UpdatesDifference &result = UpdatesDifference();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUpdatesGetDifferenceAnswer(qint64 msgId, const UpdatesDifference &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UpdatesDifference >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT updatesGetDifferenceAnswer(msgId, result);
}

void TelegramCore::onUpdatesGetDifferenceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UpdatesDifference &result = UpdatesDifference();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesDifference >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT updatesGetDifferenceError(msgId, errorCode, errorText);
}


qint64 TelegramCore::uploadSaveFilePart(qint64 file_id, qint32 file_part, const QByteArray &bytes, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->uploadSaveFilePart(file_id, file_part, bytes);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "uploadSaveFilePart";
        mRecallArgs[msgId]["file_id"] = QVariant::fromValue<qint64>(file_id);
        mRecallArgs[msgId]["file_part"] = QVariant::fromValue<qint32>(file_part);
        mRecallArgs[msgId]["bytes"] = QVariant::fromValue<QByteArray>(bytes);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUploadSaveFilePartAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT uploadSaveFilePartAnswer(msgId, result);
}

void TelegramCore::onUploadSaveFilePartError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT uploadSaveFilePartError(msgId, errorCode, errorText);
}

qint64 TelegramCore::uploadGetFile(const InputFileLocation &location, qint32 offset, qint32 limit, Callback<UploadFile > callBack, qint32 timeout) {
    if(!mApi) {
        const UploadFile &result = UploadFile();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->uploadGetFile(location, offset, limit);
    if(msgId) {
        callBackPush<UploadFile >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "uploadGetFile";
        mRecallArgs[msgId]["location"] = QVariant::fromValue<InputFileLocation>(location);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const UploadFile &result = UploadFile();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUploadGetFileAnswer(qint64 msgId, const UploadFile &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UploadFile >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT uploadGetFileAnswer(msgId, result);
}

void TelegramCore::onUploadGetFileError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UploadFile &result = UploadFile();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UploadFile >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT uploadGetFileError(msgId, errorCode, errorText);
}

qint64 TelegramCore::uploadSaveBigFilePart(qint64 file_id, qint32 file_part, qint32 file_total_parts, const QByteArray &bytes, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->uploadSaveBigFilePart(file_id, file_part, file_total_parts, bytes);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "uploadSaveBigFilePart";
        mRecallArgs[msgId]["file_id"] = QVariant::fromValue<qint64>(file_id);
        mRecallArgs[msgId]["file_part"] = QVariant::fromValue<qint32>(file_part);
        mRecallArgs[msgId]["file_total_parts"] = QVariant::fromValue<qint32>(file_total_parts);
        mRecallArgs[msgId]["bytes"] = QVariant::fromValue<QByteArray>(bytes);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUploadSaveBigFilePartAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT uploadSaveBigFilePartAnswer(msgId, result);
}

void TelegramCore::onUploadSaveBigFilePartError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT uploadSaveBigFilePartError(msgId, errorCode, errorText);
}


qint64 TelegramCore::usersGetUsers(const QList<InputUser> &id, Callback<QList<User> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<User> &result = QList<User>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->usersGetUsers(id);
    if(msgId) {
        callBackPush<QList<User> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "usersGetUsers";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<InputUser>>(id);
    } else {
        const QList<User> &result = QList<User>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUsersGetUsersAnswer(qint64 msgId, const QList<User> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<QList<User> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT usersGetUsersAnswer(msgId, result);
}

void TelegramCore::onUsersGetUsersError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const QList<User> &result = QList<User>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<User> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT usersGetUsersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::usersGetFullUser(const InputUser &id, Callback<UserFull > callBack, qint32 timeout) {
    if(!mApi) {
        const UserFull &result = UserFull();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->usersGetFullUser(id);
    if(msgId) {
        callBackPush<UserFull >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "usersGetFullUser";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputUser>(id);
    } else {
        const UserFull &result = UserFull();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUsersGetFullUserAnswer(qint64 msgId, const UserFull &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    callBackCall<UserFull >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT usersGetFullUserAnswer(msgId, result);
}

void TelegramCore::onUsersGetFullUserError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mLastArgs = mRecallArgs.take(msgId);
    const UserFull &result = UserFull();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UserFull >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT usersGetFullUserError(msgId, errorCode, errorText);
}


void TelegramCore::onError(qint64 id, qint32 errorCode, const QString &errorText, const QString &functionName, const QVariant &attachedData, bool &accepted)
{
    Q_EMIT error(id, errorCode, errorText, functionName);
    Q_UNUSED(accepted)
    Q_UNUSED(attachedData)
}

qint64 TelegramCore::retry(qint64 mid)
{
    qint64 result = 0;
    if(!mRecallArgs.contains(mid))
        return result;
    const QVariantHash &args = mRecallArgs.take(mid);
    const QString &functionName = args.value("").toString();
    if(functionName.isEmpty())
        return result;
    if(functionName == "accountRegisterDevice") {
        result = accountRegisterDevice(args["token_type"].value<qint32>(), args["token"].value<QString>(), args["device_model"].value<QString>(), args["system_version"].value<QString>(), args["app_version"].value<QString>(), args["app_sandbox"].value<bool>(), args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountUnregisterDevice") {
        result = accountUnregisterDevice(args["token_type"].value<qint32>(), args["token"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountUpdateNotifySettings") {
        result = accountUpdateNotifySettings(args["peer"].value<InputNotifyPeer>(), args["settings"].value<InputPeerNotifySettings>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetNotifySettings") {
        result = accountGetNotifySettings(args["peer"].value<InputNotifyPeer>(), [this, mid](TG_CALLBACK_SIGNATURE(PeerNotifySettings)){ Q_UNUSED(msgId); callBackCall<PeerNotifySettings>(mid, result, error); } );
    } else if(functionName == "accountResetNotifySettings") {
        result = accountResetNotifySettings([this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountUpdateProfile") {
        result = accountUpdateProfile(args["first_name"].value<QString>(), args["last_name"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(User)){ Q_UNUSED(msgId); callBackCall<User>(mid, result, error); } );
    } else if(functionName == "accountUpdateStatus") {
        result = accountUpdateStatus(args["offline"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetWallPapers") {
        result = accountGetWallPapers([this, mid](TG_CALLBACK_SIGNATURE(QList<WallPaper>)){ Q_UNUSED(msgId); callBackCall<QList<WallPaper>>(mid, result, error); } );
    } else if(functionName == "accountCheckUsername") {
        result = accountCheckUsername(args["username"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountUpdateUsername") {
        result = accountUpdateUsername(args["username"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(User)){ Q_UNUSED(msgId); callBackCall<User>(mid, result, error); } );
    } else if(functionName == "accountGetPrivacy") {
        result = accountGetPrivacy(args["key"].value<InputPrivacyKey>(), [this, mid](TG_CALLBACK_SIGNATURE(AccountPrivacyRules)){ Q_UNUSED(msgId); callBackCall<AccountPrivacyRules>(mid, result, error); } );
    } else if(functionName == "accountSetPrivacy") {
        result = accountSetPrivacy(args["key"].value<InputPrivacyKey>(), args["rules"].value<QList<InputPrivacyRule>>(), [this, mid](TG_CALLBACK_SIGNATURE(AccountPrivacyRules)){ Q_UNUSED(msgId); callBackCall<AccountPrivacyRules>(mid, result, error); } );
    } else if(functionName == "accountDeleteAccount") {
        result = accountDeleteAccount(args["reason"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetAccountTTL") {
        result = accountGetAccountTTL([this, mid](TG_CALLBACK_SIGNATURE(AccountDaysTTL)){ Q_UNUSED(msgId); callBackCall<AccountDaysTTL>(mid, result, error); } );
    } else if(functionName == "accountSetAccountTTL") {
        result = accountSetAccountTTL(args["ttl"].value<AccountDaysTTL>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountSendChangePhoneCode") {
        result = accountSendChangePhoneCode(args["phone_number"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AccountSentChangePhoneCode)){ Q_UNUSED(msgId); callBackCall<AccountSentChangePhoneCode>(mid, result, error); } );
    } else if(functionName == "accountChangePhone") {
        result = accountChangePhone(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), args["phone_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(User)){ Q_UNUSED(msgId); callBackCall<User>(mid, result, error); } );
    } else if(functionName == "accountUpdateDeviceLocked") {
        result = accountUpdateDeviceLocked(args["period"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetAuthorizations") {
        result = accountGetAuthorizations([this, mid](TG_CALLBACK_SIGNATURE(AccountAuthorizations)){ Q_UNUSED(msgId); callBackCall<AccountAuthorizations>(mid, result, error); } );
    } else if(functionName == "accountResetAuthorization") {
        result = accountResetAuthorization(args["hash"].value<qint64>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetPassword") {
        result = accountGetPassword([this, mid](TG_CALLBACK_SIGNATURE(AccountPassword)){ Q_UNUSED(msgId); callBackCall<AccountPassword>(mid, result, error); } );
    } else if(functionName == "accountGetPasswordSettings") {
        result = accountGetPasswordSettings(args["current_password_hash"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(AccountPasswordSettings)){ Q_UNUSED(msgId); callBackCall<AccountPasswordSettings>(mid, result, error); } );
    } else if(functionName == "accountUpdatePasswordSettings") {
        result = accountUpdatePasswordSettings(args["current_password_hash"].value<QByteArray>(), args["new_settings"].value<AccountPasswordInputSettings>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authImportBotAuthorization") {
        result = authImportBotAuthorization(args["flags"].value<qint32>(), args["api_id"].value<qint32>(), args["api_hash"].value<QString>(), args["bot_auth_token"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authCheckPhone") {
        result = authCheckPhone(args["phone_number"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthCheckedPhone)){ Q_UNUSED(msgId); callBackCall<AuthCheckedPhone>(mid, result, error); } );
    } else if(functionName == "authSendCode") {
        result = authSendCode(args["phone_number"].value<QString>(), args["sms_type"].value<qint32>(), args["api_id"].value<qint32>(), args["api_hash"].value<QString>(), args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthSentCode)){ Q_UNUSED(msgId); callBackCall<AuthSentCode>(mid, result, error); } );
    } else if(functionName == "authSendCall") {
        result = authSendCall(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authSignUp") {
        result = authSignUp(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), args["phone_code"].value<QString>(), args["first_name"].value<QString>(), args["last_name"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authSignIn") {
        result = authSignIn(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), args["phone_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authLogOut") {
        result = authLogOut([this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authResetAuthorizations") {
        result = authResetAuthorizations([this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authSendInvites") {
        result = authSendInvites(args["phone_numbers"].value<QList<QString>>(), args["message"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authExportAuthorization") {
        result = authExportAuthorization(args["dc_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthExportedAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthExportedAuthorization>(mid, result, error); } );
    } else if(functionName == "authImportAuthorization") {
        result = authImportAuthorization(args["id"].value<qint32>(), args["bytes"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authBindTempAuthKey") {
        result = authBindTempAuthKey(args["perm_auth_key_id"].value<qint64>(), args["nonce"].value<qint64>(), args["expires_at"].value<qint32>(), args["encrypted_message"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authSendSms") {
        result = authSendSms(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authCheckPassword") {
        result = authCheckPassword(args["password_hash"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authRequestPasswordRecovery") {
        result = authRequestPasswordRecovery([this, mid](TG_CALLBACK_SIGNATURE(AuthPasswordRecovery)){ Q_UNUSED(msgId); callBackCall<AuthPasswordRecovery>(mid, result, error); } );
    } else if(functionName == "authRecoverPassword") {
        result = authRecoverPassword(args["code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "contactsGetStatuses") {
        result = contactsGetStatuses([this, mid](TG_CALLBACK_SIGNATURE(QList<ContactStatus>)){ Q_UNUSED(msgId); callBackCall<QList<ContactStatus>>(mid, result, error); } );
    } else if(functionName == "contactsGetContacts") {
        result = contactsGetContacts(args["hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsContacts)){ Q_UNUSED(msgId); callBackCall<ContactsContacts>(mid, result, error); } );
    } else if(functionName == "contactsImportContacts") {
        result = contactsImportContacts(args["contacts"].value<QList<InputContact>>(), args["replace"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsImportedContacts)){ Q_UNUSED(msgId); callBackCall<ContactsImportedContacts>(mid, result, error); } );
    } else if(functionName == "contactsGetSuggested") {
        result = contactsGetSuggested(args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsSuggested)){ Q_UNUSED(msgId); callBackCall<ContactsSuggested>(mid, result, error); } );
    } else if(functionName == "contactsDeleteContact") {
        result = contactsDeleteContact(args["id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsLink)){ Q_UNUSED(msgId); callBackCall<ContactsLink>(mid, result, error); } );
    } else if(functionName == "contactsDeleteContacts") {
        result = contactsDeleteContacts(args["id"].value<QList<InputUser>>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "contactsBlock") {
        result = contactsBlock(args["id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "contactsUnblock") {
        result = contactsUnblock(args["id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "contactsGetBlocked") {
        result = contactsGetBlocked(args["offset"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsBlocked)){ Q_UNUSED(msgId); callBackCall<ContactsBlocked>(mid, result, error); } );
    } else if(functionName == "contactsExportCard") {
        result = contactsExportCard([this, mid](TG_CALLBACK_SIGNATURE(QList<qint32>)){ Q_UNUSED(msgId); callBackCall<QList<qint32>>(mid, result, error); } );
    } else if(functionName == "contactsImportCard") {
        result = contactsImportCard(args["export_card"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(User)){ Q_UNUSED(msgId); callBackCall<User>(mid, result, error); } );
    } else if(functionName == "contactsSearch") {
        result = contactsSearch(args["q"].value<QString>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsFound)){ Q_UNUSED(msgId); callBackCall<ContactsFound>(mid, result, error); } );
    } else if(functionName == "contactsResolveUsername") {
        result = contactsResolveUsername(args["username"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(User)){ Q_UNUSED(msgId); callBackCall<User>(mid, result, error); } );
    } else if(functionName == "geochatsGetLocated") {
        result = geochatsGetLocated(args["geo_point"].value<InputGeoPoint>(), args["radius"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsLocated)){ Q_UNUSED(msgId); callBackCall<GeochatsLocated>(mid, result, error); } );
    } else if(functionName == "geochatsGetRecents") {
        result = geochatsGetRecents(args["offset"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsMessages)){ Q_UNUSED(msgId); callBackCall<GeochatsMessages>(mid, result, error); } );
    } else if(functionName == "geochatsCheckin") {
        result = geochatsCheckin(args["peer"].value<InputGeoChat>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsStatedMessage)){ Q_UNUSED(msgId); callBackCall<GeochatsStatedMessage>(mid, result, error); } );
    } else if(functionName == "geochatsGetFullChat") {
        result = geochatsGetFullChat(args["peer"].value<InputGeoChat>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesChatFull)){ Q_UNUSED(msgId); callBackCall<MessagesChatFull>(mid, result, error); } );
    } else if(functionName == "geochatsEditChatTitle") {
        result = geochatsEditChatTitle(args["peer"].value<InputGeoChat>(), args["title"].value<QString>(), args["address"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsStatedMessage)){ Q_UNUSED(msgId); callBackCall<GeochatsStatedMessage>(mid, result, error); } );
    } else if(functionName == "geochatsEditChatPhoto") {
        result = geochatsEditChatPhoto(args["peer"].value<InputGeoChat>(), args["photo"].value<InputChatPhoto>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsStatedMessage)){ Q_UNUSED(msgId); callBackCall<GeochatsStatedMessage>(mid, result, error); } );
    } else if(functionName == "geochatsSearch") {
        result = geochatsSearch(args["peer"].value<InputGeoChat>(), args["q"].value<QString>(), args["filter"].value<MessagesFilter>(), args["min_date"].value<qint32>(), args["max_date"].value<qint32>(), args["offset"].value<qint32>(), args["max_id"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsMessages)){ Q_UNUSED(msgId); callBackCall<GeochatsMessages>(mid, result, error); } );
    } else if(functionName == "geochatsGetHistory") {
        result = geochatsGetHistory(args["peer"].value<InputGeoChat>(), args["offset"].value<qint32>(), args["max_id"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsMessages)){ Q_UNUSED(msgId); callBackCall<GeochatsMessages>(mid, result, error); } );
    } else if(functionName == "geochatsSetTyping") {
        result = geochatsSetTyping(args["peer"].value<InputGeoChat>(), args["typing"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "geochatsSendMessage") {
        result = geochatsSendMessage(args["peer"].value<InputGeoChat>(), args["message"].value<QString>(), args["random_id"].value<qint64>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsStatedMessage)){ Q_UNUSED(msgId); callBackCall<GeochatsStatedMessage>(mid, result, error); } );
    } else if(functionName == "geochatsSendMedia") {
        result = geochatsSendMedia(args["peer"].value<InputGeoChat>(), args["media"].value<InputMedia>(), args["random_id"].value<qint64>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsStatedMessage)){ Q_UNUSED(msgId); callBackCall<GeochatsStatedMessage>(mid, result, error); } );
    } else if(functionName == "geochatsCreateGeoChat") {
        result = geochatsCreateGeoChat(args["title"].value<QString>(), args["geo_point"].value<InputGeoPoint>(), args["address"].value<QString>(), args["venue"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(GeochatsStatedMessage)){ Q_UNUSED(msgId); callBackCall<GeochatsStatedMessage>(mid, result, error); } );
    } else if(functionName == "helpGetConfig") {
        result = helpGetConfig([this, mid](TG_CALLBACK_SIGNATURE(Config)){ Q_UNUSED(msgId); callBackCall<Config>(mid, result, error); } );
    } else if(functionName == "helpGetNearestDc") {
        result = helpGetNearestDc([this, mid](TG_CALLBACK_SIGNATURE(NearestDc)){ Q_UNUSED(msgId); callBackCall<NearestDc>(mid, result, error); } );
    } else if(functionName == "helpGetAppUpdate") {
        result = helpGetAppUpdate(args["device_model"].value<QString>(), args["system_version"].value<QString>(), args["app_version"].value<QString>(), args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(HelpAppUpdate)){ Q_UNUSED(msgId); callBackCall<HelpAppUpdate>(mid, result, error); } );
    } else if(functionName == "helpSaveAppLog") {
        result = helpSaveAppLog(args["events"].value<QList<InputAppEvent>>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "helpGetInviteText") {
        result = helpGetInviteText(args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(HelpInviteText)){ Q_UNUSED(msgId); callBackCall<HelpInviteText>(mid, result, error); } );
    } else if(functionName == "helpGetSupport") {
        result = helpGetSupport([this, mid](TG_CALLBACK_SIGNATURE(HelpSupport)){ Q_UNUSED(msgId); callBackCall<HelpSupport>(mid, result, error); } );
    } else if(functionName == "messagesStartBot") {
        result = messagesStartBot(args["bot"].value<InputUser>(), args["chat_id"].value<qint32>(), args["random_id"].value<qint64>(), args["start_param"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesGetMessages") {
        result = messagesGetMessages(args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesMessages)){ Q_UNUSED(msgId); callBackCall<MessagesMessages>(mid, result, error); } );
    } else if(functionName == "messagesGetDialogs") {
        result = messagesGetDialogs(args["offset"].value<qint32>(), args["max_id"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesDialogs)){ Q_UNUSED(msgId); callBackCall<MessagesDialogs>(mid, result, error); } );
    } else if(functionName == "messagesGetHistory") {
        result = messagesGetHistory(args["peer"].value<InputPeer>(), args["offset"].value<qint32>(), args["max_id"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesMessages)){ Q_UNUSED(msgId); callBackCall<MessagesMessages>(mid, result, error); } );
    } else if(functionName == "messagesSearch") {
        result = messagesSearch(args["peer"].value<InputPeer>(), args["q"].value<QString>(), args["filter"].value<MessagesFilter>(), args["min_date"].value<qint32>(), args["max_date"].value<qint32>(), args["offset"].value<qint32>(), args["max_id"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesMessages)){ Q_UNUSED(msgId); callBackCall<MessagesMessages>(mid, result, error); } );
    } else if(functionName == "messagesReadHistory") {
        result = messagesReadHistory(args["peer"].value<InputPeer>(), args["max_id"].value<qint32>(), args["offset"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedHistory)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedHistory>(mid, result, error); } );
    } else if(functionName == "messagesDeleteHistory") {
        result = messagesDeleteHistory(args["peer"].value<InputPeer>(), args["offset"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedHistory)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedHistory>(mid, result, error); } );
    } else if(functionName == "messagesDeleteMessages") {
        result = messagesDeleteMessages(args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedMessages)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedMessages>(mid, result, error); } );
    } else if(functionName == "messagesReceivedMessages") {
        result = messagesReceivedMessages(args["max_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(QList<ReceivedNotifyMessage>)){ Q_UNUSED(msgId); callBackCall<QList<ReceivedNotifyMessage>>(mid, result, error); } );
    } else if(functionName == "messagesSetTyping") {
        result = messagesSetTyping(args["peer"].value<InputPeer>(), args["action"].value<SendMessageAction>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesSendMessage") {
        result = messagesSendMessage(args["peer"].value<InputPeer>(), args["reply_to_msg_id"].value<qint32>(), args["message"].value<QString>(), args["random_id"].value<qint64>(), args["reply_markup"].value<ReplyMarkup>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesSentMessage)){ Q_UNUSED(msgId); callBackCall<MessagesSentMessage>(mid, result, error); } );
    } else if(functionName == "messagesSendMedia") {
        result = messagesSendMedia(args["peer"].value<InputPeer>(), args["reply_to_msg_id"].value<qint32>(), args["media"].value<InputMedia>(), args["random_id"].value<qint64>(), args["reply_markup"].value<ReplyMarkup>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesForwardMessages") {
        result = messagesForwardMessages(args["peer"].value<InputPeer>(), args["id"].value<QList<qint32>>(), args["random_id"].value<QList<qint64>>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesGetChats") {
        result = messagesGetChats(args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesChats)){ Q_UNUSED(msgId); callBackCall<MessagesChats>(mid, result, error); } );
    } else if(functionName == "messagesGetFullChat") {
        result = messagesGetFullChat(args["chat_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesChatFull)){ Q_UNUSED(msgId); callBackCall<MessagesChatFull>(mid, result, error); } );
    } else if(functionName == "messagesEditChatTitle") {
        result = messagesEditChatTitle(args["chat_id"].value<qint32>(), args["title"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesEditChatPhoto") {
        result = messagesEditChatPhoto(args["chat_id"].value<qint32>(), args["photo"].value<InputChatPhoto>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesAddChatUser") {
        result = messagesAddChatUser(args["chat_id"].value<qint32>(), args["user_id"].value<InputUser>(), args["fwd_limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesDeleteChatUser") {
        result = messagesDeleteChatUser(args["chat_id"].value<qint32>(), args["user_id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesCreateChat") {
        result = messagesCreateChat(args["users"].value<QList<InputUser>>(), args["title"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesForwardMessage") {
        result = messagesForwardMessage(args["peer"].value<InputPeer>(), args["id"].value<qint32>(), args["random_id"].value<qint64>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesSendBroadcast") {
        result = messagesSendBroadcast(args["contacts"].value<QList<InputUser>>(), args["random_id"].value<QList<qint64>>(), args["message"].value<QString>(), args["media"].value<InputMedia>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesGetDhConfig") {
        result = messagesGetDhConfig(args["version"].value<qint32>(), args["random_length"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesDhConfig)){ Q_UNUSED(msgId); callBackCall<MessagesDhConfig>(mid, result, error); } );
    } else if(functionName == "messagesRequestEncryption") {
        result = messagesRequestEncryption(args["user_id"].value<InputUser>(), args["random_id"].value<qint32>(), args["g_a"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(EncryptedChat)){ Q_UNUSED(msgId); callBackCall<EncryptedChat>(mid, result, error); } );
    } else if(functionName == "messagesAcceptEncryption") {
        result = messagesAcceptEncryption(args["peer"].value<InputEncryptedChat>(), args["g_b"].value<QByteArray>(), args["key_fingerprint"].value<qint64>(), [this, mid](TG_CALLBACK_SIGNATURE(EncryptedChat)){ Q_UNUSED(msgId); callBackCall<EncryptedChat>(mid, result, error); } );
    } else if(functionName == "messagesDiscardEncryption") {
        result = messagesDiscardEncryption(args["chat_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesSetEncryptedTyping") {
        result = messagesSetEncryptedTyping(args["peer"].value<InputEncryptedChat>(), args["typing"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesReadEncryptedHistory") {
        result = messagesReadEncryptedHistory(args["peer"].value<InputEncryptedChat>(), args["max_date"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesSendEncrypted") {
        result = messagesSendEncrypted(args["peer"].value<InputEncryptedChat>(), args["random_id"].value<qint64>(), args["data"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesSentEncryptedMessage)){ Q_UNUSED(msgId); callBackCall<MessagesSentEncryptedMessage>(mid, result, error); } );
    } else if(functionName == "messagesSendEncryptedFile") {
        result = messagesSendEncryptedFile(args["peer"].value<InputEncryptedChat>(), args["random_id"].value<qint64>(), args["data"].value<QByteArray>(), args["file"].value<InputEncryptedFile>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesSentEncryptedMessage)){ Q_UNUSED(msgId); callBackCall<MessagesSentEncryptedMessage>(mid, result, error); } );
    } else if(functionName == "messagesSendEncryptedService") {
        result = messagesSendEncryptedService(args["peer"].value<InputEncryptedChat>(), args["random_id"].value<qint64>(), args["data"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesSentEncryptedMessage)){ Q_UNUSED(msgId); callBackCall<MessagesSentEncryptedMessage>(mid, result, error); } );
    } else if(functionName == "messagesReceivedQueue") {
        result = messagesReceivedQueue(args["max_qts"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(QList<qint64>)){ Q_UNUSED(msgId); callBackCall<QList<qint64>>(mid, result, error); } );
    } else if(functionName == "messagesReadMessageContents") {
        result = messagesReadMessageContents(args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedMessages)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedMessages>(mid, result, error); } );
    } else if(functionName == "messagesGetStickers") {
        result = messagesGetStickers(args["emoticon"].value<QString>(), args["hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesStickers)){ Q_UNUSED(msgId); callBackCall<MessagesStickers>(mid, result, error); } );
    } else if(functionName == "messagesGetAllStickers") {
        result = messagesGetAllStickers(args["hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAllStickers)){ Q_UNUSED(msgId); callBackCall<MessagesAllStickers>(mid, result, error); } );
    } else if(functionName == "messagesGetWebPagePreview") {
        result = messagesGetWebPagePreview(args["message"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(MessageMedia)){ Q_UNUSED(msgId); callBackCall<MessageMedia>(mid, result, error); } );
    } else if(functionName == "messagesExportChatInvite") {
        result = messagesExportChatInvite(args["chat_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(ExportedChatInvite)){ Q_UNUSED(msgId); callBackCall<ExportedChatInvite>(mid, result, error); } );
    } else if(functionName == "messagesCheckChatInvite") {
        result = messagesCheckChatInvite(args["hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(ChatInvite)){ Q_UNUSED(msgId); callBackCall<ChatInvite>(mid, result, error); } );
    } else if(functionName == "messagesImportChatInvite") {
        result = messagesImportChatInvite(args["hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesGetStickerSet") {
        result = messagesGetStickerSet(args["stickerset"].value<InputStickerSet>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesStickerSet)){ Q_UNUSED(msgId); callBackCall<MessagesStickerSet>(mid, result, error); } );
    } else if(functionName == "messagesInstallStickerSet") {
        result = messagesInstallStickerSet(args["stickerset"].value<InputStickerSet>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesUninstallStickerSet") {
        result = messagesUninstallStickerSet(args["stickerset"].value<InputStickerSet>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "photosUpdateProfilePhoto") {
        result = photosUpdateProfilePhoto(args["id"].value<InputPhoto>(), args["crop"].value<InputPhotoCrop>(), [this, mid](TG_CALLBACK_SIGNATURE(UserProfilePhoto)){ Q_UNUSED(msgId); callBackCall<UserProfilePhoto>(mid, result, error); } );
    } else if(functionName == "photosUploadProfilePhoto") {
        result = photosUploadProfilePhoto(args["file"].value<InputFile>(), args["caption"].value<QString>(), args["geo_point"].value<InputGeoPoint>(), args["crop"].value<InputPhotoCrop>(), [this, mid](TG_CALLBACK_SIGNATURE(PhotosPhoto)){ Q_UNUSED(msgId); callBackCall<PhotosPhoto>(mid, result, error); } );
    } else if(functionName == "photosDeletePhotos") {
        result = photosDeletePhotos(args["id"].value<QList<InputPhoto>>(), [this, mid](TG_CALLBACK_SIGNATURE(QList<qint64>)){ Q_UNUSED(msgId); callBackCall<QList<qint64>>(mid, result, error); } );
    } else if(functionName == "photosGetUserPhotos") {
        result = photosGetUserPhotos(args["user_id"].value<InputUser>(), args["offset"].value<qint32>(), args["max_id"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(PhotosPhotos)){ Q_UNUSED(msgId); callBackCall<PhotosPhotos>(mid, result, error); } );
    } else if(functionName == "updatesGetState") {
        result = updatesGetState([this, mid](TG_CALLBACK_SIGNATURE(UpdatesState)){ Q_UNUSED(msgId); callBackCall<UpdatesState>(mid, result, error); } );
    } else if(functionName == "updatesGetDifference") {
        result = updatesGetDifference(args["pts"].value<qint32>(), args["date"].value<qint32>(), args["qts"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesDifference)){ Q_UNUSED(msgId); callBackCall<UpdatesDifference>(mid, result, error); } );
    } else if(functionName == "uploadSaveFilePart") {
        result = uploadSaveFilePart(args["file_id"].value<qint64>(), args["file_part"].value<qint32>(), args["bytes"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "uploadGetFile") {
        result = uploadGetFile(args["location"].value<InputFileLocation>(), args["offset"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(UploadFile)){ Q_UNUSED(msgId); callBackCall<UploadFile>(mid, result, error); } );
    } else if(functionName == "uploadSaveBigFilePart") {
        result = uploadSaveBigFilePart(args["file_id"].value<qint64>(), args["file_part"].value<qint32>(), args["file_total_parts"].value<qint32>(), args["bytes"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "usersGetUsers") {
        result = usersGetUsers(args["id"].value<QList<InputUser>>(), [this, mid](TG_CALLBACK_SIGNATURE(QList<User>)){ Q_UNUSED(msgId); callBackCall<QList<User>>(mid, result, error); } );
    } else if(functionName == "usersGetFullUser") {
        result = usersGetFullUser(args["id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(UserFull)){ Q_UNUSED(msgId); callBackCall<UserFull>(mid, result, error); } );
    } else  {
        return result;
    }

    return result;
}

bool TelegramCore::isConnected() const {
    if (mApi && mApi->mainSession()) {
        return mApi->mainSession()->state() == QAbstractSocket::ConnectedState;
    }
    return false;
}

void TelegramCore::timerEvent(QTimerEvent *e)
{
    const qint64 msgId = mTimer.key(e->timerId());
    if(msgId && isConnected())
    {
        mTimer.remove(msgId);
        killTimer(e->timerId());
        qDebug() << "Timed out. Retrying msgId=" << msgId;
        retry(msgId);
    }

    QObject::timerEvent(e);
}

TelegramCore::~TelegramCore()
{
    mCallbacks.clear();
}

